"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/storyblok-js-client";
exports.ids = ["vendor-chunks/storyblok-js-client"];
exports.modules = {

/***/ "(rsc)/./node_modules/storyblok-js-client/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/storyblok-js-client/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Storyblok: () => (/* binding */ Storyblok),\n/* harmony export */   \"default\": () => (/* binding */ src_default)\n/* harmony export */ });\n//#region src/throttlePromise.ts\nvar AbortError = class extends Error {\n\tconstructor(msg) {\n\t\tsuper(msg);\n\t\tthis.name = \"AbortError\";\n\t}\n};\nfunction throttledQueue(fn, limit, interval) {\n\tif (!Number.isFinite(limit)) throw new TypeError(\"Expected `limit` to be a finite number\");\n\tif (!Number.isFinite(interval)) throw new TypeError(\"Expected `interval` to be a finite number\");\n\tconst queue = [];\n\tlet timeouts = [];\n\tlet activeCount = 0;\n\tlet isAborted = false;\n\tconst next = async () => {\n\t\tactiveCount++;\n\t\tconst x = queue.shift();\n\t\tif (x) try {\n\t\t\tconst res = await fn(...x.args);\n\t\t\tx.resolve(res);\n\t\t} catch (error) {\n\t\t\tx.reject(error);\n\t\t}\n\t\tconst id = setTimeout(() => {\n\t\t\tactiveCount--;\n\t\t\tif (queue.length > 0) next();\n\t\t\ttimeouts = timeouts.filter((currentId) => currentId !== id);\n\t\t}, interval);\n\t\tif (!timeouts.includes(id)) timeouts.push(id);\n\t};\n\tconst throttled = (...args) => {\n\t\tif (isAborted) return Promise.reject(/* @__PURE__ */ new Error(\"Throttled function is already aborted and not accepting new promises\"));\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tqueue.push({\n\t\t\t\tresolve,\n\t\t\t\treject,\n\t\t\t\targs\n\t\t\t});\n\t\t\tif (activeCount < limit) next();\n\t\t});\n\t};\n\tthrottled.abort = () => {\n\t\tisAborted = true;\n\t\ttimeouts.forEach(clearTimeout);\n\t\ttimeouts = [];\n\t\tqueue.forEach((x) => x.reject(() => new AbortError(\"Throttle function aborted\")));\n\t\tqueue.length = 0;\n\t};\n\treturn throttled;\n}\nvar throttlePromise_default = throttledQueue;\n\n//#endregion\n//#region src/utils.ts\n/**\n* Checks if a URL is a CDN URL\n* @param url - The URL to check\n* @returns boolean indicating if the URL is a CDN URL\n*/\nconst isCDNUrl = (url = \"\") => url.includes(\"/cdn/\");\n/**\n* Gets pagination options for the API request\n* @param options - The base options\n* @param perPage - Number of items per page\n* @param page - Current page number\n* @returns Object with pagination options\n*/\nconst getOptionsPage = (options, perPage = 25, page = 1) => ({\n\t...options,\n\tper_page: perPage,\n\tpage\n});\n/**\n* Creates a promise that resolves after the specified milliseconds\n* @param ms - Milliseconds to delay\n* @returns Promise that resolves after the delay\n*/\nconst delay = (ms) => new Promise((res) => setTimeout(res, ms));\n/**\n* Creates an array of specified length using a mapping function\n* @param length - Length of the array\n* @param func - Mapping function\n* @returns Array of specified length\n*/\nconst arrayFrom = (length = 0, func) => Array.from({ length }, func);\n/**\n* Creates an array of numbers in the specified range\n* @param start - Start of the range\n* @param end - End of the range\n* @returns Array of numbers in the range\n*/\nconst range = (start = 0, end = start) => {\n\tconst length = Math.abs(end - start) || 0;\n\tconst step = start < end ? 1 : -1;\n\treturn arrayFrom(length, (_, i) => i * step + start);\n};\n/**\n* Maps an array asynchronously\n* @param arr - Array to map\n* @param func - Async mapping function\n* @returns Promise resolving to mapped array\n*/\nconst asyncMap = async (arr, func) => Promise.all(arr.map(func));\n/**\n* Flattens an array using a mapping function\n* @param arr - Array to flatten\n* @param func - Mapping function\n* @returns Flattened array\n*/\nconst flatMap = (arr = [], func) => arr.map(func).reduce((xs, ys) => [...xs, ...ys], []);\n/**\n* Stringifies an object into a URL query string\n* @param params - Parameters to stringify\n* @param prefix - Prefix for nested keys\n* @param isArray - Whether the current level is an array\n* @returns Stringified query parameters\n*/\nconst stringify = (params, prefix, isArray) => {\n\tconst pairs = [];\n\tfor (const key in params) {\n\t\tif (!Object.prototype.hasOwnProperty.call(params, key)) continue;\n\t\tconst value = params[key];\n\t\tif (value === null || value === void 0) continue;\n\t\tconst enkey = isArray ? \"\" : encodeURIComponent(key);\n\t\tlet pair;\n\t\tif (typeof value === \"object\") pair = stringify(value, prefix ? prefix + encodeURIComponent(`[${enkey}]`) : enkey, Array.isArray(value));\n\t\telse pair = `${prefix ? prefix + encodeURIComponent(`[${enkey}]`) : enkey}=${encodeURIComponent(value)}`;\n\t\tpairs.push(pair);\n\t}\n\treturn pairs.join(\"&\");\n};\n/**\n* Gets the base URL for a specific region\n* @param regionCode - Region code (eu, us, cn, ap, ca)\n* @returns Base URL for the region\n*/\nconst getRegionURL = (regionCode) => {\n\tconst REGION_URLS = {\n\t\teu: \"api.storyblok.com\",\n\t\tus: \"api-us.storyblok.com\",\n\t\tcn: \"app.storyblokchina.cn\",\n\t\tap: \"api-ap.storyblok.com\",\n\t\tca: \"api-ca.storyblok.com\"\n\t};\n\treturn REGION_URLS[regionCode] ?? REGION_URLS.eu;\n};\n\n//#endregion\n//#region src/sbFetch.ts\nvar SbFetch = class {\n\tbaseURL;\n\ttimeout;\n\theaders;\n\tresponseInterceptor;\n\tfetch;\n\tejectInterceptor;\n\turl;\n\tparameters;\n\tfetchOptions;\n\tconstructor($c) {\n\t\tthis.baseURL = $c.baseURL;\n\t\tthis.headers = $c.headers || new Headers();\n\t\tthis.timeout = $c?.timeout ? $c.timeout * 1e3 : 0;\n\t\tthis.responseInterceptor = $c.responseInterceptor;\n\t\tthis.fetch = (...args) => $c.fetch ? $c.fetch(...args) : fetch(...args);\n\t\tthis.ejectInterceptor = false;\n\t\tthis.url = \"\";\n\t\tthis.parameters = {};\n\t\tthis.fetchOptions = {};\n\t}\n\t/**\n\t*\n\t* @param url string\n\t* @param params ISbStoriesParams\n\t* @returns Promise<ISbResponse | Error>\n\t*/\n\tget(url, params) {\n\t\tthis.url = url;\n\t\tthis.parameters = params;\n\t\treturn this._methodHandler(\"get\");\n\t}\n\tpost(url, params) {\n\t\tthis.url = url;\n\t\tthis.parameters = params;\n\t\treturn this._methodHandler(\"post\");\n\t}\n\tput(url, params) {\n\t\tthis.url = url;\n\t\tthis.parameters = params;\n\t\treturn this._methodHandler(\"put\");\n\t}\n\tdelete(url, params) {\n\t\tthis.url = url;\n\t\tthis.parameters = params ?? {};\n\t\treturn this._methodHandler(\"delete\");\n\t}\n\tasync _responseHandler(res) {\n\t\tconst headers = [];\n\t\tconst response = {\n\t\t\tdata: {},\n\t\t\theaders: {},\n\t\t\tstatus: 0,\n\t\t\tstatusText: \"\"\n\t\t};\n\t\tif (res.status !== 204) await res.json().then(($r) => {\n\t\t\tresponse.data = $r;\n\t\t});\n\t\tfor (const pair of res.headers.entries()) headers[pair[0]] = pair[1];\n\t\tresponse.headers = { ...headers };\n\t\tresponse.status = res.status;\n\t\tresponse.statusText = res.statusText;\n\t\treturn response;\n\t}\n\tasync _methodHandler(method) {\n\t\tlet urlString = `${this.baseURL}${this.url}`;\n\t\tlet body = null;\n\t\tif (method === \"get\") urlString = `${this.baseURL}${this.url}?${stringify(this.parameters)}`;\n\t\telse body = JSON.stringify(this.parameters);\n\t\tconst url = new URL(urlString);\n\t\tconst controller = new AbortController();\n\t\tconst { signal } = controller;\n\t\tlet timeout;\n\t\tif (this.timeout) timeout = setTimeout(() => controller.abort(), this.timeout);\n\t\ttry {\n\t\t\tconst fetchResponse = await this.fetch(`${url}`, {\n\t\t\t\tmethod,\n\t\t\t\theaders: this.headers,\n\t\t\t\tbody,\n\t\t\t\tsignal,\n\t\t\t\t...this.fetchOptions\n\t\t\t});\n\t\t\tif (this.timeout) clearTimeout(timeout);\n\t\t\tconst response = await this._responseHandler(fetchResponse);\n\t\t\tif (this.responseInterceptor && !this.ejectInterceptor) return this._statusHandler(this.responseInterceptor(response));\n\t\t\telse return this._statusHandler(response);\n\t\t} catch (err) {\n\t\t\tconst error = { message: err };\n\t\t\treturn error;\n\t\t}\n\t}\n\tsetFetchOptions(fetchOptions = {}) {\n\t\tif (Object.keys(fetchOptions).length > 0 && \"method\" in fetchOptions) delete fetchOptions.method;\n\t\tthis.fetchOptions = { ...fetchOptions };\n\t}\n\teject() {\n\t\tthis.ejectInterceptor = true;\n\t}\n\t/**\n\t* Normalizes error messages from different response structures\n\t* @param data The response data that might contain error information\n\t* @returns A normalized error message string\n\t*/\n\t_normalizeErrorMessage(data) {\n\t\tif (Array.isArray(data)) return data[0] || \"Unknown error\";\n\t\tif (data && typeof data === \"object\") {\n\t\t\tif (data.error) return data.error;\n\t\t\tfor (const key in data) {\n\t\t\t\tif (Array.isArray(data[key])) return `${key}: ${data[key][0]}`;\n\t\t\t\tif (typeof data[key] === \"string\") return `${key}: ${data[key]}`;\n\t\t\t}\n\t\t\tif (data.slug) return data.slug;\n\t\t}\n\t\treturn \"Unknown error\";\n\t}\n\t_statusHandler(res) {\n\t\tconst statusOk = /20[0-6]/g;\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tif (statusOk.test(`${res.status}`)) return resolve(res);\n\t\t\tconst error = {\n\t\t\t\tmessage: this._normalizeErrorMessage(res.data),\n\t\t\t\tstatus: res.status,\n\t\t\t\tresponse: res\n\t\t\t};\n\t\t\treject(error);\n\t\t});\n\t}\n};\nvar sbFetch_default = SbFetch;\n\n//#endregion\n//#region src/constants.ts\nconst STORYBLOK_AGENT = \"SB-Agent\";\nconst STORYBLOK_JS_CLIENT_AGENT = {\n\tdefaultAgentName: \"SB-JS-CLIENT\",\n\tdefaultAgentVersion: \"SB-Agent-Version\",\n\tpackageVersion: \"7.0.0\"\n};\nconst StoryblokContentVersion = {\n\tDRAFT: \"draft\",\n\tPUBLISHED: \"published\"\n};\nconst StoryblokContentVersionValues = Object.values(StoryblokContentVersion);\n\n//#endregion\n//#region src/index.ts\nlet memory = {};\nconst cacheVersions = {};\nvar Storyblok = class {\n\tclient;\n\tmaxRetries;\n\tretriesDelay;\n\tthrottle;\n\taccessToken;\n\tcache;\n\tresolveCounter;\n\trelations;\n\tlinks;\n\tversion;\n\t/**\n\t* @deprecated This property is deprecated. Use the standalone `richTextResolver` from `@storyblok/richtext` instead.\n\t* @see https://github.com/storyblok/richtext\n\t*/\n\trichTextResolver;\n\tresolveNestedRelations;\n\tstringifiedStoriesCache;\n\tinlineAssets;\n\t/**\n\t*\n\t* @param config ISbConfig interface\n\t* @param pEndpoint string, optional\n\t*/\n\tconstructor(config, pEndpoint) {\n\t\tlet endpoint = config.endpoint || pEndpoint;\n\t\tif (!endpoint) {\n\t\t\tconst protocol = config.https === false ? \"http\" : \"https\";\n\t\t\tif (!config.oauthToken) endpoint = `${protocol}://${getRegionURL(config.region)}/v2`;\n\t\t\telse endpoint = `${protocol}://${getRegionURL(config.region)}/v1`;\n\t\t}\n\t\tconst headers = new Headers();\n\t\theaders.set(\"Content-Type\", \"application/json\");\n\t\theaders.set(\"Accept\", \"application/json\");\n\t\tif (config.headers) {\n\t\t\tconst entries = config.headers.constructor.name === \"Headers\" ? config.headers.entries().toArray() : Object.entries(config.headers);\n\t\t\tentries.forEach(([key, value]) => {\n\t\t\t\theaders.set(key, value);\n\t\t\t});\n\t\t}\n\t\tif (!headers.has(STORYBLOK_AGENT)) {\n\t\t\theaders.set(STORYBLOK_AGENT, STORYBLOK_JS_CLIENT_AGENT.defaultAgentName);\n\t\t\theaders.set(STORYBLOK_JS_CLIENT_AGENT.defaultAgentVersion, STORYBLOK_JS_CLIENT_AGENT.packageVersion);\n\t\t}\n\t\tlet rateLimit = 5;\n\t\tif (config.oauthToken) {\n\t\t\theaders.set(\"Authorization\", config.oauthToken);\n\t\t\trateLimit = 3;\n\t\t}\n\t\tif (config.rateLimit) rateLimit = config.rateLimit;\n\t\tthis.maxRetries = config.maxRetries || 10;\n\t\tthis.retriesDelay = 300;\n\t\tthis.throttle = throttlePromise_default(this.throttledRequest.bind(this), rateLimit, 1e3);\n\t\tthis.accessToken = config.accessToken || \"\";\n\t\tthis.relations = {};\n\t\tthis.links = {};\n\t\tthis.cache = config.cache || { clear: \"manual\" };\n\t\tthis.resolveCounter = 0;\n\t\tthis.resolveNestedRelations = config.resolveNestedRelations || true;\n\t\tthis.stringifiedStoriesCache = {};\n\t\tthis.version = config.version || StoryblokContentVersion.PUBLISHED;\n\t\tthis.inlineAssets = config.inlineAssets || false;\n\t\tthis.client = new sbFetch_default({\n\t\t\tbaseURL: endpoint,\n\t\t\ttimeout: config.timeout || 0,\n\t\t\theaders,\n\t\t\tresponseInterceptor: config.responseInterceptor,\n\t\t\tfetch: config.fetch\n\t\t});\n\t}\n\tparseParams(params) {\n\t\tif (!params.token) params.token = this.getToken();\n\t\tif (!params.cv) params.cv = cacheVersions[params.token];\n\t\tif (Array.isArray(params.resolve_relations)) params.resolve_relations = params.resolve_relations.join(\",\");\n\t\tif (typeof params.resolve_relations !== \"undefined\") params.resolve_level = 2;\n\t\treturn params;\n\t}\n\tfactoryParamOptions(url, params) {\n\t\tif (isCDNUrl(url)) return this.parseParams(params);\n\t\treturn params;\n\t}\n\tmakeRequest(url, params, per_page, page, fetchOptions) {\n\t\tconst query = this.factoryParamOptions(url, getOptionsPage(params, per_page, page));\n\t\treturn this.cacheResponse(url, query, void 0, fetchOptions);\n\t}\n\tget(slug, params = {}, fetchOptions) {\n\t\tif (!params) params = {};\n\t\tconst url = `/${slug}`;\n\t\tif (isCDNUrl(url)) params.version = params.version || this.version;\n\t\tconst query = this.factoryParamOptions(url, params);\n\t\treturn this.cacheResponse(url, query, void 0, fetchOptions);\n\t}\n\tasync getAll(slug, params = {}, entity, fetchOptions) {\n\t\tconst perPage = params?.per_page || 25;\n\t\tconst url = `/${slug}`.replace(/\\/$/, \"\");\n\t\tconst e = entity ?? url.substring(url.lastIndexOf(\"/\") + 1);\n\t\tparams.version = params.version || this.version;\n\t\tconst firstPage = 1;\n\t\tconst firstRes = await this.makeRequest(url, params, perPage, firstPage, fetchOptions);\n\t\tconst lastPage = firstRes.total ? Math.ceil(firstRes.total / (firstRes.perPage || perPage)) : 1;\n\t\tconst restRes = await asyncMap(range(firstPage, lastPage), (i) => {\n\t\t\treturn this.makeRequest(url, params, perPage, i + 1, fetchOptions);\n\t\t});\n\t\treturn flatMap([firstRes, ...restRes], (res) => Object.values(res.data[e]));\n\t}\n\tpost(slug, params = {}, fetchOptions) {\n\t\tconst url = `/${slug}`;\n\t\treturn this.throttle(\"post\", url, params, fetchOptions);\n\t}\n\tput(slug, params = {}, fetchOptions) {\n\t\tconst url = `/${slug}`;\n\t\treturn this.throttle(\"put\", url, params, fetchOptions);\n\t}\n\tdelete(slug, params = {}, fetchOptions) {\n\t\tif (!params) params = {};\n\t\tconst url = `/${slug}`;\n\t\treturn this.throttle(\"delete\", url, params, fetchOptions);\n\t}\n\tgetStories(params = {}, fetchOptions) {\n\t\tthis._addResolveLevel(params);\n\t\treturn this.get(\"cdn/stories\", params, fetchOptions);\n\t}\n\tgetStory(slug, params = {}, fetchOptions) {\n\t\tthis._addResolveLevel(params);\n\t\treturn this.get(`cdn/stories/${slug}`, params, fetchOptions);\n\t}\n\tgetToken() {\n\t\treturn this.accessToken;\n\t}\n\tejectInterceptor() {\n\t\tthis.client.eject();\n\t}\n\t_addResolveLevel(params) {\n\t\tif (typeof params.resolve_relations !== \"undefined\") params.resolve_level = 2;\n\t}\n\t_cleanCopy(value) {\n\t\treturn JSON.parse(JSON.stringify(value));\n\t}\n\t_insertLinks(jtree, treeItem, resolveId) {\n\t\tconst node = jtree[treeItem];\n\t\tif (node && node.fieldtype === \"multilink\" && node.linktype === \"story\" && typeof node.id === \"string\" && this.links[resolveId][node.id]) node.story = this._cleanCopy(this.links[resolveId][node.id]);\n\t\telse if (node && node.linktype === \"story\" && typeof node.uuid === \"string\" && this.links[resolveId][node.uuid]) node.story = this._cleanCopy(this.links[resolveId][node.uuid]);\n\t}\n\t/**\n\t*\n\t* @param resolveId A counter number as a string\n\t* @param uuid The uuid of the story\n\t* @returns string | object\n\t*/\n\tgetStoryReference(resolveId, uuid) {\n\t\tconst result = this.relations[resolveId][uuid] ? JSON.parse(this.stringifiedStoriesCache[uuid] || JSON.stringify(this.relations[resolveId][uuid])) : uuid;\n\t\treturn result;\n\t}\n\t/**\n\t* Resolves a field's value by replacing UUIDs with their corresponding story references\n\t* @param jtree - The JSON tree object containing the field to resolve\n\t* @param treeItem - The key of the field to resolve\n\t* @param resolveId - The unique identifier for the current resolution context\n\t*\n\t* This method handles both single string UUIDs and arrays of UUIDs:\n\t* - For single strings: directly replaces the UUID with the story reference\n\t* - For arrays: maps through each UUID and replaces with corresponding story references\n\t*/\n\t_resolveField(jtree, treeItem, resolveId) {\n\t\tconst item = jtree[treeItem];\n\t\tif (typeof item === \"string\") jtree[treeItem] = this.getStoryReference(resolveId, item);\n\t\telse if (Array.isArray(item)) jtree[treeItem] = item.map((uuid) => this.getStoryReference(resolveId, uuid)).filter(Boolean);\n\t}\n\t/**\n\t* Inserts relations into the JSON tree by resolving references\n\t* @param jtree - The JSON tree object to process\n\t* @param treeItem - The current field being processed\n\t* @param fields - The relation patterns to resolve (string or array of strings)\n\t* @param resolveId - The unique identifier for the current resolution context\n\t*\n\t* This method handles two types of relation patterns:\n\t* 1. Nested relations: matches fields that end with the current field name\n\t*    Example: If treeItem is \"event_type\", it matches patterns like \"*.event_type\"\n\t*\n\t* 2. Direct component relations: matches exact component.field patterns\n\t*    Example: \"event.event_type\" for component \"event\" and field \"event_type\"\n\t*\n\t* The method supports both string and array formats for the fields parameter,\n\t* allowing flexible specification of relation patterns.\n\t*/\n\t_insertRelations(jtree, treeItem, fields, resolveId) {\n\t\tconst fieldPattern = Array.isArray(fields) ? fields.find((f) => f.endsWith(`.${treeItem}`)) : fields.endsWith(`.${treeItem}`);\n\t\tif (fieldPattern) {\n\t\t\tthis._resolveField(jtree, treeItem, resolveId);\n\t\t\treturn;\n\t\t}\n\t\tconst fieldPath = jtree.component ? `${jtree.component}.${treeItem}` : treeItem;\n\t\tif (Array.isArray(fields) ? fields.includes(fieldPath) : fields === fieldPath) this._resolveField(jtree, treeItem, resolveId);\n\t}\n\t/**\n\t* Recursively traverses and resolves relations in the story content tree\n\t* @param story - The story object containing the content to process\n\t* @param fields - The relation patterns to resolve\n\t* @param resolveId - The unique identifier for the current resolution context\n\t*/\n\titerateTree(story, fields, resolveId) {\n\t\tconst enrich = (jtree, path = \"\") => {\n\t\t\tif (!jtree || jtree._stopResolving) return;\n\t\t\tif (Array.isArray(jtree)) jtree.forEach((item, index) => enrich(item, `${path}[${index}]`));\n\t\t\telse if (typeof jtree === \"object\") for (const key in jtree) {\n\t\t\t\tconst newPath = path ? `${path}.${key}` : key;\n\t\t\t\tif (jtree.component && jtree._uid || jtree.type === \"link\") {\n\t\t\t\t\tthis._insertRelations(jtree, key, fields, resolveId);\n\t\t\t\t\tthis._insertLinks(jtree, key, resolveId);\n\t\t\t\t}\n\t\t\t\tenrich(jtree[key], newPath);\n\t\t\t}\n\t\t};\n\t\tenrich(story.content);\n\t}\n\tasync resolveLinks(responseData, params, resolveId) {\n\t\tlet links = [];\n\t\tif (responseData.link_uuids) {\n\t\t\tconst relSize = responseData.link_uuids.length;\n\t\t\tconst chunks = [];\n\t\t\tconst chunkSize = 50;\n\t\t\tfor (let i = 0; i < relSize; i += chunkSize) {\n\t\t\t\tconst end = Math.min(relSize, i + chunkSize);\n\t\t\t\tchunks.push(responseData.link_uuids.slice(i, end));\n\t\t\t}\n\t\t\tfor (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {\n\t\t\t\tconst linksRes = await this.getStories({\n\t\t\t\t\tper_page: chunkSize,\n\t\t\t\t\tlanguage: params.language,\n\t\t\t\t\tversion: params.version,\n\t\t\t\t\tstarts_with: params.starts_with,\n\t\t\t\t\tby_uuids: chunks[chunkIndex].join(\",\")\n\t\t\t\t});\n\t\t\t\tlinksRes.data.stories.forEach((rel) => {\n\t\t\t\t\tlinks.push(rel);\n\t\t\t\t});\n\t\t\t}\n\t\t} else links = responseData.links;\n\t\tlinks.forEach((story) => {\n\t\t\tthis.links[resolveId][story.uuid] = {\n\t\t\t\t...story,\n\t\t\t\t_stopResolving: true\n\t\t\t};\n\t\t});\n\t}\n\tasync resolveRelations(responseData, params, resolveId) {\n\t\tlet relations = [];\n\t\tif (responseData.rel_uuids) {\n\t\t\tconst relSize = responseData.rel_uuids.length;\n\t\t\tconst chunks = [];\n\t\t\tconst chunkSize = 50;\n\t\t\tfor (let i = 0; i < relSize; i += chunkSize) {\n\t\t\t\tconst end = Math.min(relSize, i + chunkSize);\n\t\t\t\tchunks.push(responseData.rel_uuids.slice(i, end));\n\t\t\t}\n\t\t\tfor (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {\n\t\t\t\tconst relationsRes = await this.getStories({\n\t\t\t\t\tper_page: chunkSize,\n\t\t\t\t\tlanguage: params.language,\n\t\t\t\t\tversion: params.version,\n\t\t\t\t\tstarts_with: params.starts_with,\n\t\t\t\t\tby_uuids: chunks[chunkIndex].join(\",\"),\n\t\t\t\t\texcluding_fields: params.excluding_fields\n\t\t\t\t});\n\t\t\t\trelationsRes.data.stories.forEach((rel) => {\n\t\t\t\t\trelations.push(rel);\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (relations.length > 0) {\n\t\t\t\tresponseData.rels = relations;\n\t\t\t\tdelete responseData.rel_uuids;\n\t\t\t}\n\t\t} else relations = responseData.rels;\n\t\tif (relations && relations.length > 0) relations.forEach((story) => {\n\t\t\tthis.relations[resolveId][story.uuid] = {\n\t\t\t\t...story,\n\t\t\t\t_stopResolving: true\n\t\t\t};\n\t\t});\n\t}\n\t/**\n\t*\n\t* @param responseData\n\t* @param params\n\t* @param resolveId\n\t* @description Resolves the relations and links of the stories\n\t* @returns Promise<void>\n\t*\n\t*/\n\tasync resolveStories(responseData, params, resolveId) {\n\t\tlet relationParams = [];\n\t\tthis.links[resolveId] = {};\n\t\tthis.relations[resolveId] = {};\n\t\tif (typeof params.resolve_relations !== \"undefined\" && params.resolve_relations.length > 0) {\n\t\t\tif (typeof params.resolve_relations === \"string\") relationParams = params.resolve_relations.split(\",\");\n\t\t\tawait this.resolveRelations(responseData, params, resolveId);\n\t\t}\n\t\tif (params.resolve_links && [\n\t\t\t\"1\",\n\t\t\t\"story\",\n\t\t\t\"url\",\n\t\t\t\"link\"\n\t\t].includes(params.resolve_links) && (responseData.links?.length || responseData.link_uuids?.length)) await this.resolveLinks(responseData, params, resolveId);\n\t\tif (this.resolveNestedRelations) for (const relUuid in this.relations[resolveId]) this.iterateTree(this.relations[resolveId][relUuid], relationParams, resolveId);\n\t\tif (responseData.story) this.iterateTree(responseData.story, relationParams, resolveId);\n\t\telse responseData.stories.forEach((story) => {\n\t\t\tthis.iterateTree(story, relationParams, resolveId);\n\t\t});\n\t\tthis.stringifiedStoriesCache = {};\n\t\tdelete this.links[resolveId];\n\t\tdelete this.relations[resolveId];\n\t}\n\tasync cacheResponse(url, params, retries, fetchOptions) {\n\t\tconst cacheKey = stringify({\n\t\t\turl,\n\t\t\tparams\n\t\t});\n\t\tconst provider = this.cacheProvider();\n\t\tif (params.version === \"published\" && url !== \"/cdn/spaces/me\") {\n\t\t\tconst cache = await provider.get(cacheKey);\n\t\t\tif (cache) return Promise.resolve(cache);\n\t\t}\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tconst res = await this.throttle(\"get\", url, params, fetchOptions);\n\t\t\t\tif (res.status !== 200) return reject(res);\n\t\t\t\tlet response = {\n\t\t\t\t\tdata: res.data,\n\t\t\t\t\theaders: res.headers\n\t\t\t\t};\n\t\t\t\tif (res.headers?.[\"per-page\"]) response = Object.assign({}, response, {\n\t\t\t\t\tperPage: res.headers[\"per-page\"] ? Number.parseInt(res.headers[\"per-page\"]) : 0,\n\t\t\t\t\ttotal: res.headers[\"per-page\"] ? Number.parseInt(res.headers.total) : 0\n\t\t\t\t});\n\t\t\t\tif (response.data.story || response.data.stories) {\n\t\t\t\t\tconst resolveId = this.resolveCounter = ++this.resolveCounter % 1e3;\n\t\t\t\t\tawait this.resolveStories(response.data, params, `${resolveId}`);\n\t\t\t\t\tresponse = await this.processInlineAssets(response);\n\t\t\t\t}\n\t\t\t\tif (params.version === \"published\" && url !== \"/cdn/spaces/me\") await provider.set(cacheKey, response);\n\t\t\t\tconst isCacheClearable = this.cache.clear === \"onpreview\" && params.version === \"draft\" || this.cache.clear === \"auto\";\n\t\t\t\tif (params.token && response.data.cv) {\n\t\t\t\t\tif (isCacheClearable && cacheVersions[params.token] && cacheVersions[params.token] !== response.data.cv) await this.flushCache();\n\t\t\t\t\tcacheVersions[params.token] = response.data.cv;\n\t\t\t\t}\n\t\t\t\treturn resolve(response);\n\t\t\t} catch (error) {\n\t\t\t\tif (error.response && error.status === 429) {\n\t\t\t\t\tretries = typeof retries === \"undefined\" ? 0 : retries + 1;\n\t\t\t\t\tif (retries < this.maxRetries) {\n\t\t\t\t\t\tconsole.log(`Hit rate limit. Retrying in ${this.retriesDelay / 1e3} seconds.`);\n\t\t\t\t\t\tawait delay(this.retriesDelay);\n\t\t\t\t\t\treturn this.cacheResponse(url, params, retries).then(resolve).catch(reject);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treject(error);\n\t\t\t}\n\t\t});\n\t}\n\tthrottledRequest(type, url, params, fetchOptions) {\n\t\tthis.client.setFetchOptions(fetchOptions);\n\t\treturn this.client[type](url, params);\n\t}\n\tcacheVersions() {\n\t\treturn cacheVersions;\n\t}\n\tcacheVersion() {\n\t\treturn cacheVersions[this.accessToken];\n\t}\n\tsetCacheVersion(cv) {\n\t\tif (this.accessToken) cacheVersions[this.accessToken] = cv;\n\t}\n\tclearCacheVersion() {\n\t\tif (this.accessToken) cacheVersions[this.accessToken] = 0;\n\t}\n\tcacheProvider() {\n\t\tswitch (this.cache.type) {\n\t\t\tcase \"memory\": return {\n\t\t\t\tget(key) {\n\t\t\t\t\treturn Promise.resolve(memory[key]);\n\t\t\t\t},\n\t\t\t\tgetAll() {\n\t\t\t\t\treturn Promise.resolve(memory);\n\t\t\t\t},\n\t\t\t\tset(key, content) {\n\t\t\t\t\tmemory[key] = content;\n\t\t\t\t\treturn Promise.resolve(void 0);\n\t\t\t\t},\n\t\t\t\tflush() {\n\t\t\t\t\tmemory = {};\n\t\t\t\t\treturn Promise.resolve(void 0);\n\t\t\t\t}\n\t\t\t};\n\t\t\tcase \"custom\": if (this.cache.custom) return this.cache.custom;\n\t\t\tdefault: return {\n\t\t\t\tget() {\n\t\t\t\t\treturn Promise.resolve();\n\t\t\t\t},\n\t\t\t\tgetAll() {\n\t\t\t\t\treturn Promise.resolve(void 0);\n\t\t\t\t},\n\t\t\t\tset() {\n\t\t\t\t\treturn Promise.resolve(void 0);\n\t\t\t\t},\n\t\t\t\tflush() {\n\t\t\t\t\treturn Promise.resolve(void 0);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\tasync flushCache() {\n\t\tawait this.cacheProvider().flush();\n\t\tthis.clearCacheVersion();\n\t\treturn this;\n\t}\n\tasync processInlineAssets(response) {\n\t\tif (!this.inlineAssets) return response;\n\t\tconst processNode = (node) => {\n\t\t\tif (!node || typeof node !== \"object\") return node;\n\t\t\tif (Array.isArray(node)) return node.map((item) => processNode(item));\n\t\t\tlet processedNode = { ...node };\n\t\t\tif (processedNode.fieldtype === \"asset\" && Array.isArray(response.data.assets)) processedNode = {\n\t\t\t\t...processedNode,\n\t\t\t\t...response.data.assets.find((asset) => asset.id === processedNode.id)\n\t\t\t};\n\t\t\tfor (const key in processedNode) if (typeof processedNode[key] === \"object\") processedNode[key] = processNode(processedNode[key]);\n\t\t\treturn processedNode;\n\t\t};\n\t\tif (response.data.story) response.data.story.content = processNode(response.data.story.content);\n\t\tif (response.data.stories) response.data.stories = response.data.stories.map((story) => {\n\t\t\tstory.content = processNode(story.content);\n\t\t\treturn story;\n\t\t});\n\t\treturn response;\n\t}\n};\nvar src_default = Storyblok;\n\n//#endregion\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3RvcnlibG9rLWpzLWNsaWVudC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFFBQVE7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0csTUFBTTtBQUN4RyxpQkFBaUIseUNBQXlDLE1BQU0sWUFBWSxHQUFHLDBCQUEwQjtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHlEQUF5RCxVQUFVO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQseUJBQXlCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDNkM7QUFDN0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXJ0aW4vcGVyc29uYWwtcHJvamVjdHMvc3RvcnlibG9rL3N0b3J5LXRyYXZlbC1hZ2VuY3kvbm9kZV9tb2R1bGVzL3N0b3J5Ymxvay1qcy1jbGllbnQvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyNyZWdpb24gc3JjL3Rocm90dGxlUHJvbWlzZS50c1xudmFyIEFib3J0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcblx0Y29uc3RydWN0b3IobXNnKSB7XG5cdFx0c3VwZXIobXNnKTtcblx0XHR0aGlzLm5hbWUgPSBcIkFib3J0RXJyb3JcIjtcblx0fVxufTtcbmZ1bmN0aW9uIHRocm90dGxlZFF1ZXVlKGZuLCBsaW1pdCwgaW50ZXJ2YWwpIHtcblx0aWYgKCFOdW1iZXIuaXNGaW5pdGUobGltaXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYGxpbWl0YCB0byBiZSBhIGZpbml0ZSBudW1iZXJcIik7XG5cdGlmICghTnVtYmVyLmlzRmluaXRlKGludGVydmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGBpbnRlcnZhbGAgdG8gYmUgYSBmaW5pdGUgbnVtYmVyXCIpO1xuXHRjb25zdCBxdWV1ZSA9IFtdO1xuXHRsZXQgdGltZW91dHMgPSBbXTtcblx0bGV0IGFjdGl2ZUNvdW50ID0gMDtcblx0bGV0IGlzQWJvcnRlZCA9IGZhbHNlO1xuXHRjb25zdCBuZXh0ID0gYXN5bmMgKCkgPT4ge1xuXHRcdGFjdGl2ZUNvdW50Kys7XG5cdFx0Y29uc3QgeCA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0aWYgKHgpIHRyeSB7XG5cdFx0XHRjb25zdCByZXMgPSBhd2FpdCBmbiguLi54LmFyZ3MpO1xuXHRcdFx0eC5yZXNvbHZlKHJlcyk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHgucmVqZWN0KGVycm9yKTtcblx0XHR9XG5cdFx0Y29uc3QgaWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdGFjdGl2ZUNvdW50LS07XG5cdFx0XHRpZiAocXVldWUubGVuZ3RoID4gMCkgbmV4dCgpO1xuXHRcdFx0dGltZW91dHMgPSB0aW1lb3V0cy5maWx0ZXIoKGN1cnJlbnRJZCkgPT4gY3VycmVudElkICE9PSBpZCk7XG5cdFx0fSwgaW50ZXJ2YWwpO1xuXHRcdGlmICghdGltZW91dHMuaW5jbHVkZXMoaWQpKSB0aW1lb3V0cy5wdXNoKGlkKTtcblx0fTtcblx0Y29uc3QgdGhyb3R0bGVkID0gKC4uLmFyZ3MpID0+IHtcblx0XHRpZiAoaXNBYm9ydGVkKSByZXR1cm4gUHJvbWlzZS5yZWplY3QoLyogQF9fUFVSRV9fICovIG5ldyBFcnJvcihcIlRocm90dGxlZCBmdW5jdGlvbiBpcyBhbHJlYWR5IGFib3J0ZWQgYW5kIG5vdCBhY2NlcHRpbmcgbmV3IHByb21pc2VzXCIpKTtcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdFx0cXVldWUucHVzaCh7XG5cdFx0XHRcdHJlc29sdmUsXG5cdFx0XHRcdHJlamVjdCxcblx0XHRcdFx0YXJnc1xuXHRcdFx0fSk7XG5cdFx0XHRpZiAoYWN0aXZlQ291bnQgPCBsaW1pdCkgbmV4dCgpO1xuXHRcdH0pO1xuXHR9O1xuXHR0aHJvdHRsZWQuYWJvcnQgPSAoKSA9PiB7XG5cdFx0aXNBYm9ydGVkID0gdHJ1ZTtcblx0XHR0aW1lb3V0cy5mb3JFYWNoKGNsZWFyVGltZW91dCk7XG5cdFx0dGltZW91dHMgPSBbXTtcblx0XHRxdWV1ZS5mb3JFYWNoKCh4KSA9PiB4LnJlamVjdCgoKSA9PiBuZXcgQWJvcnRFcnJvcihcIlRocm90dGxlIGZ1bmN0aW9uIGFib3J0ZWRcIikpKTtcblx0XHRxdWV1ZS5sZW5ndGggPSAwO1xuXHR9O1xuXHRyZXR1cm4gdGhyb3R0bGVkO1xufVxudmFyIHRocm90dGxlUHJvbWlzZV9kZWZhdWx0ID0gdGhyb3R0bGVkUXVldWU7XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91dGlscy50c1xuLyoqXG4qIENoZWNrcyBpZiBhIFVSTCBpcyBhIENETiBVUkxcbiogQHBhcmFtIHVybCAtIFRoZSBVUkwgdG8gY2hlY2tcbiogQHJldHVybnMgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBVUkwgaXMgYSBDRE4gVVJMXG4qL1xuY29uc3QgaXNDRE5VcmwgPSAodXJsID0gXCJcIikgPT4gdXJsLmluY2x1ZGVzKFwiL2Nkbi9cIik7XG4vKipcbiogR2V0cyBwYWdpbmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBBUEkgcmVxdWVzdFxuKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBiYXNlIG9wdGlvbnNcbiogQHBhcmFtIHBlclBhZ2UgLSBOdW1iZXIgb2YgaXRlbXMgcGVyIHBhZ2VcbiogQHBhcmFtIHBhZ2UgLSBDdXJyZW50IHBhZ2UgbnVtYmVyXG4qIEByZXR1cm5zIE9iamVjdCB3aXRoIHBhZ2luYXRpb24gb3B0aW9uc1xuKi9cbmNvbnN0IGdldE9wdGlvbnNQYWdlID0gKG9wdGlvbnMsIHBlclBhZ2UgPSAyNSwgcGFnZSA9IDEpID0+ICh7XG5cdC4uLm9wdGlvbnMsXG5cdHBlcl9wYWdlOiBwZXJQYWdlLFxuXHRwYWdlXG59KTtcbi8qKlxuKiBDcmVhdGVzIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIGFmdGVyIHRoZSBzcGVjaWZpZWQgbWlsbGlzZWNvbmRzXG4qIEBwYXJhbSBtcyAtIE1pbGxpc2Vjb25kcyB0byBkZWxheVxuKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgYWZ0ZXIgdGhlIGRlbGF5XG4qL1xuY29uc3QgZGVsYXkgPSAobXMpID0+IG5ldyBQcm9taXNlKChyZXMpID0+IHNldFRpbWVvdXQocmVzLCBtcykpO1xuLyoqXG4qIENyZWF0ZXMgYW4gYXJyYXkgb2Ygc3BlY2lmaWVkIGxlbmd0aCB1c2luZyBhIG1hcHBpbmcgZnVuY3Rpb25cbiogQHBhcmFtIGxlbmd0aCAtIExlbmd0aCBvZiB0aGUgYXJyYXlcbiogQHBhcmFtIGZ1bmMgLSBNYXBwaW5nIGZ1bmN0aW9uXG4qIEByZXR1cm5zIEFycmF5IG9mIHNwZWNpZmllZCBsZW5ndGhcbiovXG5jb25zdCBhcnJheUZyb20gPSAobGVuZ3RoID0gMCwgZnVuYykgPT4gQXJyYXkuZnJvbSh7IGxlbmd0aCB9LCBmdW5jKTtcbi8qKlxuKiBDcmVhdGVzIGFuIGFycmF5IG9mIG51bWJlcnMgaW4gdGhlIHNwZWNpZmllZCByYW5nZVxuKiBAcGFyYW0gc3RhcnQgLSBTdGFydCBvZiB0aGUgcmFuZ2VcbiogQHBhcmFtIGVuZCAtIEVuZCBvZiB0aGUgcmFuZ2VcbiogQHJldHVybnMgQXJyYXkgb2YgbnVtYmVycyBpbiB0aGUgcmFuZ2VcbiovXG5jb25zdCByYW5nZSA9IChzdGFydCA9IDAsIGVuZCA9IHN0YXJ0KSA9PiB7XG5cdGNvbnN0IGxlbmd0aCA9IE1hdGguYWJzKGVuZCAtIHN0YXJ0KSB8fCAwO1xuXHRjb25zdCBzdGVwID0gc3RhcnQgPCBlbmQgPyAxIDogLTE7XG5cdHJldHVybiBhcnJheUZyb20obGVuZ3RoLCAoXywgaSkgPT4gaSAqIHN0ZXAgKyBzdGFydCk7XG59O1xuLyoqXG4qIE1hcHMgYW4gYXJyYXkgYXN5bmNocm9ub3VzbHlcbiogQHBhcmFtIGFyciAtIEFycmF5IHRvIG1hcFxuKiBAcGFyYW0gZnVuYyAtIEFzeW5jIG1hcHBpbmcgZnVuY3Rpb25cbiogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gbWFwcGVkIGFycmF5XG4qL1xuY29uc3QgYXN5bmNNYXAgPSBhc3luYyAoYXJyLCBmdW5jKSA9PiBQcm9taXNlLmFsbChhcnIubWFwKGZ1bmMpKTtcbi8qKlxuKiBGbGF0dGVucyBhbiBhcnJheSB1c2luZyBhIG1hcHBpbmcgZnVuY3Rpb25cbiogQHBhcmFtIGFyciAtIEFycmF5IHRvIGZsYXR0ZW5cbiogQHBhcmFtIGZ1bmMgLSBNYXBwaW5nIGZ1bmN0aW9uXG4qIEByZXR1cm5zIEZsYXR0ZW5lZCBhcnJheVxuKi9cbmNvbnN0IGZsYXRNYXAgPSAoYXJyID0gW10sIGZ1bmMpID0+IGFyci5tYXAoZnVuYykucmVkdWNlKCh4cywgeXMpID0+IFsuLi54cywgLi4ueXNdLCBbXSk7XG4vKipcbiogU3RyaW5naWZpZXMgYW4gb2JqZWN0IGludG8gYSBVUkwgcXVlcnkgc3RyaW5nXG4qIEBwYXJhbSBwYXJhbXMgLSBQYXJhbWV0ZXJzIHRvIHN0cmluZ2lmeVxuKiBAcGFyYW0gcHJlZml4IC0gUHJlZml4IGZvciBuZXN0ZWQga2V5c1xuKiBAcGFyYW0gaXNBcnJheSAtIFdoZXRoZXIgdGhlIGN1cnJlbnQgbGV2ZWwgaXMgYW4gYXJyYXlcbiogQHJldHVybnMgU3RyaW5naWZpZWQgcXVlcnkgcGFyYW1ldGVyc1xuKi9cbmNvbnN0IHN0cmluZ2lmeSA9IChwYXJhbXMsIHByZWZpeCwgaXNBcnJheSkgPT4ge1xuXHRjb25zdCBwYWlycyA9IFtdO1xuXHRmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcblx0XHRpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbXMsIGtleSkpIGNvbnRpbnVlO1xuXHRcdGNvbnN0IHZhbHVlID0gcGFyYW1zW2tleV07XG5cdFx0aWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDApIGNvbnRpbnVlO1xuXHRcdGNvbnN0IGVua2V5ID0gaXNBcnJheSA/IFwiXCIgOiBlbmNvZGVVUklDb21wb25lbnQoa2V5KTtcblx0XHRsZXQgcGFpcjtcblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSBwYWlyID0gc3RyaW5naWZ5KHZhbHVlLCBwcmVmaXggPyBwcmVmaXggKyBlbmNvZGVVUklDb21wb25lbnQoYFske2Vua2V5fV1gKSA6IGVua2V5LCBBcnJheS5pc0FycmF5KHZhbHVlKSk7XG5cdFx0ZWxzZSBwYWlyID0gYCR7cHJlZml4ID8gcHJlZml4ICsgZW5jb2RlVVJJQ29tcG9uZW50KGBbJHtlbmtleX1dYCkgOiBlbmtleX09JHtlbmNvZGVVUklDb21wb25lbnQodmFsdWUpfWA7XG5cdFx0cGFpcnMucHVzaChwYWlyKTtcblx0fVxuXHRyZXR1cm4gcGFpcnMuam9pbihcIiZcIik7XG59O1xuLyoqXG4qIEdldHMgdGhlIGJhc2UgVVJMIGZvciBhIHNwZWNpZmljIHJlZ2lvblxuKiBAcGFyYW0gcmVnaW9uQ29kZSAtIFJlZ2lvbiBjb2RlIChldSwgdXMsIGNuLCBhcCwgY2EpXG4qIEByZXR1cm5zIEJhc2UgVVJMIGZvciB0aGUgcmVnaW9uXG4qL1xuY29uc3QgZ2V0UmVnaW9uVVJMID0gKHJlZ2lvbkNvZGUpID0+IHtcblx0Y29uc3QgUkVHSU9OX1VSTFMgPSB7XG5cdFx0ZXU6IFwiYXBpLnN0b3J5Ymxvay5jb21cIixcblx0XHR1czogXCJhcGktdXMuc3RvcnlibG9rLmNvbVwiLFxuXHRcdGNuOiBcImFwcC5zdG9yeWJsb2tjaGluYS5jblwiLFxuXHRcdGFwOiBcImFwaS1hcC5zdG9yeWJsb2suY29tXCIsXG5cdFx0Y2E6IFwiYXBpLWNhLnN0b3J5Ymxvay5jb21cIlxuXHR9O1xuXHRyZXR1cm4gUkVHSU9OX1VSTFNbcmVnaW9uQ29kZV0gPz8gUkVHSU9OX1VSTFMuZXU7XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvc2JGZXRjaC50c1xudmFyIFNiRmV0Y2ggPSBjbGFzcyB7XG5cdGJhc2VVUkw7XG5cdHRpbWVvdXQ7XG5cdGhlYWRlcnM7XG5cdHJlc3BvbnNlSW50ZXJjZXB0b3I7XG5cdGZldGNoO1xuXHRlamVjdEludGVyY2VwdG9yO1xuXHR1cmw7XG5cdHBhcmFtZXRlcnM7XG5cdGZldGNoT3B0aW9ucztcblx0Y29uc3RydWN0b3IoJGMpIHtcblx0XHR0aGlzLmJhc2VVUkwgPSAkYy5iYXNlVVJMO1xuXHRcdHRoaXMuaGVhZGVycyA9ICRjLmhlYWRlcnMgfHwgbmV3IEhlYWRlcnMoKTtcblx0XHR0aGlzLnRpbWVvdXQgPSAkYz8udGltZW91dCA/ICRjLnRpbWVvdXQgKiAxZTMgOiAwO1xuXHRcdHRoaXMucmVzcG9uc2VJbnRlcmNlcHRvciA9ICRjLnJlc3BvbnNlSW50ZXJjZXB0b3I7XG5cdFx0dGhpcy5mZXRjaCA9ICguLi5hcmdzKSA9PiAkYy5mZXRjaCA/ICRjLmZldGNoKC4uLmFyZ3MpIDogZmV0Y2goLi4uYXJncyk7XG5cdFx0dGhpcy5lamVjdEludGVyY2VwdG9yID0gZmFsc2U7XG5cdFx0dGhpcy51cmwgPSBcIlwiO1xuXHRcdHRoaXMucGFyYW1ldGVycyA9IHt9O1xuXHRcdHRoaXMuZmV0Y2hPcHRpb25zID0ge307XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAcGFyYW0gdXJsIHN0cmluZ1xuXHQqIEBwYXJhbSBwYXJhbXMgSVNiU3Rvcmllc1BhcmFtc1xuXHQqIEByZXR1cm5zIFByb21pc2U8SVNiUmVzcG9uc2UgfCBFcnJvcj5cblx0Ki9cblx0Z2V0KHVybCwgcGFyYW1zKSB7XG5cdFx0dGhpcy51cmwgPSB1cmw7XG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0gcGFyYW1zO1xuXHRcdHJldHVybiB0aGlzLl9tZXRob2RIYW5kbGVyKFwiZ2V0XCIpO1xuXHR9XG5cdHBvc3QodXJsLCBwYXJhbXMpIHtcblx0XHR0aGlzLnVybCA9IHVybDtcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBwYXJhbXM7XG5cdFx0cmV0dXJuIHRoaXMuX21ldGhvZEhhbmRsZXIoXCJwb3N0XCIpO1xuXHR9XG5cdHB1dCh1cmwsIHBhcmFtcykge1xuXHRcdHRoaXMudXJsID0gdXJsO1xuXHRcdHRoaXMucGFyYW1ldGVycyA9IHBhcmFtcztcblx0XHRyZXR1cm4gdGhpcy5fbWV0aG9kSGFuZGxlcihcInB1dFwiKTtcblx0fVxuXHRkZWxldGUodXJsLCBwYXJhbXMpIHtcblx0XHR0aGlzLnVybCA9IHVybDtcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBwYXJhbXMgPz8ge307XG5cdFx0cmV0dXJuIHRoaXMuX21ldGhvZEhhbmRsZXIoXCJkZWxldGVcIik7XG5cdH1cblx0YXN5bmMgX3Jlc3BvbnNlSGFuZGxlcihyZXMpIHtcblx0XHRjb25zdCBoZWFkZXJzID0gW107XG5cdFx0Y29uc3QgcmVzcG9uc2UgPSB7XG5cdFx0XHRkYXRhOiB7fSxcblx0XHRcdGhlYWRlcnM6IHt9LFxuXHRcdFx0c3RhdHVzOiAwLFxuXHRcdFx0c3RhdHVzVGV4dDogXCJcIlxuXHRcdH07XG5cdFx0aWYgKHJlcy5zdGF0dXMgIT09IDIwNCkgYXdhaXQgcmVzLmpzb24oKS50aGVuKCgkcikgPT4ge1xuXHRcdFx0cmVzcG9uc2UuZGF0YSA9ICRyO1xuXHRcdH0pO1xuXHRcdGZvciAoY29uc3QgcGFpciBvZiByZXMuaGVhZGVycy5lbnRyaWVzKCkpIGhlYWRlcnNbcGFpclswXV0gPSBwYWlyWzFdO1xuXHRcdHJlc3BvbnNlLmhlYWRlcnMgPSB7IC4uLmhlYWRlcnMgfTtcblx0XHRyZXNwb25zZS5zdGF0dXMgPSByZXMuc3RhdHVzO1xuXHRcdHJlc3BvbnNlLnN0YXR1c1RleHQgPSByZXMuc3RhdHVzVGV4dDtcblx0XHRyZXR1cm4gcmVzcG9uc2U7XG5cdH1cblx0YXN5bmMgX21ldGhvZEhhbmRsZXIobWV0aG9kKSB7XG5cdFx0bGV0IHVybFN0cmluZyA9IGAke3RoaXMuYmFzZVVSTH0ke3RoaXMudXJsfWA7XG5cdFx0bGV0IGJvZHkgPSBudWxsO1xuXHRcdGlmIChtZXRob2QgPT09IFwiZ2V0XCIpIHVybFN0cmluZyA9IGAke3RoaXMuYmFzZVVSTH0ke3RoaXMudXJsfT8ke3N0cmluZ2lmeSh0aGlzLnBhcmFtZXRlcnMpfWA7XG5cdFx0ZWxzZSBib2R5ID0gSlNPTi5zdHJpbmdpZnkodGhpcy5wYXJhbWV0ZXJzKTtcblx0XHRjb25zdCB1cmwgPSBuZXcgVVJMKHVybFN0cmluZyk7XG5cdFx0Y29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcblx0XHRjb25zdCB7IHNpZ25hbCB9ID0gY29udHJvbGxlcjtcblx0XHRsZXQgdGltZW91dDtcblx0XHRpZiAodGhpcy50aW1lb3V0KSB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIHRoaXMudGltZW91dCk7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IGZldGNoUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoKGAke3VybH1gLCB7XG5cdFx0XHRcdG1ldGhvZCxcblx0XHRcdFx0aGVhZGVyczogdGhpcy5oZWFkZXJzLFxuXHRcdFx0XHRib2R5LFxuXHRcdFx0XHRzaWduYWwsXG5cdFx0XHRcdC4uLnRoaXMuZmV0Y2hPcHRpb25zXG5cdFx0XHR9KTtcblx0XHRcdGlmICh0aGlzLnRpbWVvdXQpIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0XHRcdGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fcmVzcG9uc2VIYW5kbGVyKGZldGNoUmVzcG9uc2UpO1xuXHRcdFx0aWYgKHRoaXMucmVzcG9uc2VJbnRlcmNlcHRvciAmJiAhdGhpcy5lamVjdEludGVyY2VwdG9yKSByZXR1cm4gdGhpcy5fc3RhdHVzSGFuZGxlcih0aGlzLnJlc3BvbnNlSW50ZXJjZXB0b3IocmVzcG9uc2UpKTtcblx0XHRcdGVsc2UgcmV0dXJuIHRoaXMuX3N0YXR1c0hhbmRsZXIocmVzcG9uc2UpO1xuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0Y29uc3QgZXJyb3IgPSB7IG1lc3NhZ2U6IGVyciB9O1xuXHRcdFx0cmV0dXJuIGVycm9yO1xuXHRcdH1cblx0fVxuXHRzZXRGZXRjaE9wdGlvbnMoZmV0Y2hPcHRpb25zID0ge30pIHtcblx0XHRpZiAoT2JqZWN0LmtleXMoZmV0Y2hPcHRpb25zKS5sZW5ndGggPiAwICYmIFwibWV0aG9kXCIgaW4gZmV0Y2hPcHRpb25zKSBkZWxldGUgZmV0Y2hPcHRpb25zLm1ldGhvZDtcblx0XHR0aGlzLmZldGNoT3B0aW9ucyA9IHsgLi4uZmV0Y2hPcHRpb25zIH07XG5cdH1cblx0ZWplY3QoKSB7XG5cdFx0dGhpcy5lamVjdEludGVyY2VwdG9yID0gdHJ1ZTtcblx0fVxuXHQvKipcblx0KiBOb3JtYWxpemVzIGVycm9yIG1lc3NhZ2VzIGZyb20gZGlmZmVyZW50IHJlc3BvbnNlIHN0cnVjdHVyZXNcblx0KiBAcGFyYW0gZGF0YSBUaGUgcmVzcG9uc2UgZGF0YSB0aGF0IG1pZ2h0IGNvbnRhaW4gZXJyb3IgaW5mb3JtYXRpb25cblx0KiBAcmV0dXJucyBBIG5vcm1hbGl6ZWQgZXJyb3IgbWVzc2FnZSBzdHJpbmdcblx0Ki9cblx0X25vcm1hbGl6ZUVycm9yTWVzc2FnZShkYXRhKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHJldHVybiBkYXRhWzBdIHx8IFwiVW5rbm93biBlcnJvclwiO1xuXHRcdGlmIChkYXRhICYmIHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRpZiAoZGF0YS5lcnJvcikgcmV0dXJuIGRhdGEuZXJyb3I7XG5cdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG5cdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KGRhdGFba2V5XSkpIHJldHVybiBgJHtrZXl9OiAke2RhdGFba2V5XVswXX1gO1xuXHRcdFx0XHRpZiAodHlwZW9mIGRhdGFba2V5XSA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGAke2tleX06ICR7ZGF0YVtrZXldfWA7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZGF0YS5zbHVnKSByZXR1cm4gZGF0YS5zbHVnO1xuXHRcdH1cblx0XHRyZXR1cm4gXCJVbmtub3duIGVycm9yXCI7XG5cdH1cblx0X3N0YXR1c0hhbmRsZXIocmVzKSB7XG5cdFx0Y29uc3Qgc3RhdHVzT2sgPSAvMjBbMC02XS9nO1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0XHRpZiAoc3RhdHVzT2sudGVzdChgJHtyZXMuc3RhdHVzfWApKSByZXR1cm4gcmVzb2x2ZShyZXMpO1xuXHRcdFx0Y29uc3QgZXJyb3IgPSB7XG5cdFx0XHRcdG1lc3NhZ2U6IHRoaXMuX25vcm1hbGl6ZUVycm9yTWVzc2FnZShyZXMuZGF0YSksXG5cdFx0XHRcdHN0YXR1czogcmVzLnN0YXR1cyxcblx0XHRcdFx0cmVzcG9uc2U6IHJlc1xuXHRcdFx0fTtcblx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0fSk7XG5cdH1cbn07XG52YXIgc2JGZXRjaF9kZWZhdWx0ID0gU2JGZXRjaDtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2NvbnN0YW50cy50c1xuY29uc3QgU1RPUllCTE9LX0FHRU5UID0gXCJTQi1BZ2VudFwiO1xuY29uc3QgU1RPUllCTE9LX0pTX0NMSUVOVF9BR0VOVCA9IHtcblx0ZGVmYXVsdEFnZW50TmFtZTogXCJTQi1KUy1DTElFTlRcIixcblx0ZGVmYXVsdEFnZW50VmVyc2lvbjogXCJTQi1BZ2VudC1WZXJzaW9uXCIsXG5cdHBhY2thZ2VWZXJzaW9uOiBcIjcuMC4wXCJcbn07XG5jb25zdCBTdG9yeWJsb2tDb250ZW50VmVyc2lvbiA9IHtcblx0RFJBRlQ6IFwiZHJhZnRcIixcblx0UFVCTElTSEVEOiBcInB1Ymxpc2hlZFwiXG59O1xuY29uc3QgU3RvcnlibG9rQ29udGVudFZlcnNpb25WYWx1ZXMgPSBPYmplY3QudmFsdWVzKFN0b3J5Ymxva0NvbnRlbnRWZXJzaW9uKTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2luZGV4LnRzXG5sZXQgbWVtb3J5ID0ge307XG5jb25zdCBjYWNoZVZlcnNpb25zID0ge307XG52YXIgU3RvcnlibG9rID0gY2xhc3Mge1xuXHRjbGllbnQ7XG5cdG1heFJldHJpZXM7XG5cdHJldHJpZXNEZWxheTtcblx0dGhyb3R0bGU7XG5cdGFjY2Vzc1Rva2VuO1xuXHRjYWNoZTtcblx0cmVzb2x2ZUNvdW50ZXI7XG5cdHJlbGF0aW9ucztcblx0bGlua3M7XG5cdHZlcnNpb247XG5cdC8qKlxuXHQqIEBkZXByZWNhdGVkIFRoaXMgcHJvcGVydHkgaXMgZGVwcmVjYXRlZC4gVXNlIHRoZSBzdGFuZGFsb25lIGByaWNoVGV4dFJlc29sdmVyYCBmcm9tIGBAc3RvcnlibG9rL3JpY2h0ZXh0YCBpbnN0ZWFkLlxuXHQqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N0b3J5Ymxvay9yaWNodGV4dFxuXHQqL1xuXHRyaWNoVGV4dFJlc29sdmVyO1xuXHRyZXNvbHZlTmVzdGVkUmVsYXRpb25zO1xuXHRzdHJpbmdpZmllZFN0b3JpZXNDYWNoZTtcblx0aW5saW5lQXNzZXRzO1xuXHQvKipcblx0KlxuXHQqIEBwYXJhbSBjb25maWcgSVNiQ29uZmlnIGludGVyZmFjZVxuXHQqIEBwYXJhbSBwRW5kcG9pbnQgc3RyaW5nLCBvcHRpb25hbFxuXHQqL1xuXHRjb25zdHJ1Y3Rvcihjb25maWcsIHBFbmRwb2ludCkge1xuXHRcdGxldCBlbmRwb2ludCA9IGNvbmZpZy5lbmRwb2ludCB8fCBwRW5kcG9pbnQ7XG5cdFx0aWYgKCFlbmRwb2ludCkge1xuXHRcdFx0Y29uc3QgcHJvdG9jb2wgPSBjb25maWcuaHR0cHMgPT09IGZhbHNlID8gXCJodHRwXCIgOiBcImh0dHBzXCI7XG5cdFx0XHRpZiAoIWNvbmZpZy5vYXV0aFRva2VuKSBlbmRwb2ludCA9IGAke3Byb3RvY29sfTovLyR7Z2V0UmVnaW9uVVJMKGNvbmZpZy5yZWdpb24pfS92MmA7XG5cdFx0XHRlbHNlIGVuZHBvaW50ID0gYCR7cHJvdG9jb2x9Oi8vJHtnZXRSZWdpb25VUkwoY29uZmlnLnJlZ2lvbil9L3YxYDtcblx0XHR9XG5cdFx0Y29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG5cdFx0aGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuXHRcdGhlYWRlcnMuc2V0KFwiQWNjZXB0XCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcblx0XHRpZiAoY29uZmlnLmhlYWRlcnMpIHtcblx0XHRcdGNvbnN0IGVudHJpZXMgPSBjb25maWcuaGVhZGVycy5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIkhlYWRlcnNcIiA/IGNvbmZpZy5oZWFkZXJzLmVudHJpZXMoKS50b0FycmF5KCkgOiBPYmplY3QuZW50cmllcyhjb25maWcuaGVhZGVycyk7XG5cdFx0XHRlbnRyaWVzLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuXHRcdFx0XHRoZWFkZXJzLnNldChrZXksIHZhbHVlKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRpZiAoIWhlYWRlcnMuaGFzKFNUT1JZQkxPS19BR0VOVCkpIHtcblx0XHRcdGhlYWRlcnMuc2V0KFNUT1JZQkxPS19BR0VOVCwgU1RPUllCTE9LX0pTX0NMSUVOVF9BR0VOVC5kZWZhdWx0QWdlbnROYW1lKTtcblx0XHRcdGhlYWRlcnMuc2V0KFNUT1JZQkxPS19KU19DTElFTlRfQUdFTlQuZGVmYXVsdEFnZW50VmVyc2lvbiwgU1RPUllCTE9LX0pTX0NMSUVOVF9BR0VOVC5wYWNrYWdlVmVyc2lvbik7XG5cdFx0fVxuXHRcdGxldCByYXRlTGltaXQgPSA1O1xuXHRcdGlmIChjb25maWcub2F1dGhUb2tlbikge1xuXHRcdFx0aGVhZGVycy5zZXQoXCJBdXRob3JpemF0aW9uXCIsIGNvbmZpZy5vYXV0aFRva2VuKTtcblx0XHRcdHJhdGVMaW1pdCA9IDM7XG5cdFx0fVxuXHRcdGlmIChjb25maWcucmF0ZUxpbWl0KSByYXRlTGltaXQgPSBjb25maWcucmF0ZUxpbWl0O1xuXHRcdHRoaXMubWF4UmV0cmllcyA9IGNvbmZpZy5tYXhSZXRyaWVzIHx8IDEwO1xuXHRcdHRoaXMucmV0cmllc0RlbGF5ID0gMzAwO1xuXHRcdHRoaXMudGhyb3R0bGUgPSB0aHJvdHRsZVByb21pc2VfZGVmYXVsdCh0aGlzLnRocm90dGxlZFJlcXVlc3QuYmluZCh0aGlzKSwgcmF0ZUxpbWl0LCAxZTMpO1xuXHRcdHRoaXMuYWNjZXNzVG9rZW4gPSBjb25maWcuYWNjZXNzVG9rZW4gfHwgXCJcIjtcblx0XHR0aGlzLnJlbGF0aW9ucyA9IHt9O1xuXHRcdHRoaXMubGlua3MgPSB7fTtcblx0XHR0aGlzLmNhY2hlID0gY29uZmlnLmNhY2hlIHx8IHsgY2xlYXI6IFwibWFudWFsXCIgfTtcblx0XHR0aGlzLnJlc29sdmVDb3VudGVyID0gMDtcblx0XHR0aGlzLnJlc29sdmVOZXN0ZWRSZWxhdGlvbnMgPSBjb25maWcucmVzb2x2ZU5lc3RlZFJlbGF0aW9ucyB8fCB0cnVlO1xuXHRcdHRoaXMuc3RyaW5naWZpZWRTdG9yaWVzQ2FjaGUgPSB7fTtcblx0XHR0aGlzLnZlcnNpb24gPSBjb25maWcudmVyc2lvbiB8fCBTdG9yeWJsb2tDb250ZW50VmVyc2lvbi5QVUJMSVNIRUQ7XG5cdFx0dGhpcy5pbmxpbmVBc3NldHMgPSBjb25maWcuaW5saW5lQXNzZXRzIHx8IGZhbHNlO1xuXHRcdHRoaXMuY2xpZW50ID0gbmV3IHNiRmV0Y2hfZGVmYXVsdCh7XG5cdFx0XHRiYXNlVVJMOiBlbmRwb2ludCxcblx0XHRcdHRpbWVvdXQ6IGNvbmZpZy50aW1lb3V0IHx8IDAsXG5cdFx0XHRoZWFkZXJzLFxuXHRcdFx0cmVzcG9uc2VJbnRlcmNlcHRvcjogY29uZmlnLnJlc3BvbnNlSW50ZXJjZXB0b3IsXG5cdFx0XHRmZXRjaDogY29uZmlnLmZldGNoXG5cdFx0fSk7XG5cdH1cblx0cGFyc2VQYXJhbXMocGFyYW1zKSB7XG5cdFx0aWYgKCFwYXJhbXMudG9rZW4pIHBhcmFtcy50b2tlbiA9IHRoaXMuZ2V0VG9rZW4oKTtcblx0XHRpZiAoIXBhcmFtcy5jdikgcGFyYW1zLmN2ID0gY2FjaGVWZXJzaW9uc1twYXJhbXMudG9rZW5dO1xuXHRcdGlmIChBcnJheS5pc0FycmF5KHBhcmFtcy5yZXNvbHZlX3JlbGF0aW9ucykpIHBhcmFtcy5yZXNvbHZlX3JlbGF0aW9ucyA9IHBhcmFtcy5yZXNvbHZlX3JlbGF0aW9ucy5qb2luKFwiLFwiKTtcblx0XHRpZiAodHlwZW9mIHBhcmFtcy5yZXNvbHZlX3JlbGF0aW9ucyAhPT0gXCJ1bmRlZmluZWRcIikgcGFyYW1zLnJlc29sdmVfbGV2ZWwgPSAyO1xuXHRcdHJldHVybiBwYXJhbXM7XG5cdH1cblx0ZmFjdG9yeVBhcmFtT3B0aW9ucyh1cmwsIHBhcmFtcykge1xuXHRcdGlmIChpc0NETlVybCh1cmwpKSByZXR1cm4gdGhpcy5wYXJzZVBhcmFtcyhwYXJhbXMpO1xuXHRcdHJldHVybiBwYXJhbXM7XG5cdH1cblx0bWFrZVJlcXVlc3QodXJsLCBwYXJhbXMsIHBlcl9wYWdlLCBwYWdlLCBmZXRjaE9wdGlvbnMpIHtcblx0XHRjb25zdCBxdWVyeSA9IHRoaXMuZmFjdG9yeVBhcmFtT3B0aW9ucyh1cmwsIGdldE9wdGlvbnNQYWdlKHBhcmFtcywgcGVyX3BhZ2UsIHBhZ2UpKTtcblx0XHRyZXR1cm4gdGhpcy5jYWNoZVJlc3BvbnNlKHVybCwgcXVlcnksIHZvaWQgMCwgZmV0Y2hPcHRpb25zKTtcblx0fVxuXHRnZXQoc2x1ZywgcGFyYW1zID0ge30sIGZldGNoT3B0aW9ucykge1xuXHRcdGlmICghcGFyYW1zKSBwYXJhbXMgPSB7fTtcblx0XHRjb25zdCB1cmwgPSBgLyR7c2x1Z31gO1xuXHRcdGlmIChpc0NETlVybCh1cmwpKSBwYXJhbXMudmVyc2lvbiA9IHBhcmFtcy52ZXJzaW9uIHx8IHRoaXMudmVyc2lvbjtcblx0XHRjb25zdCBxdWVyeSA9IHRoaXMuZmFjdG9yeVBhcmFtT3B0aW9ucyh1cmwsIHBhcmFtcyk7XG5cdFx0cmV0dXJuIHRoaXMuY2FjaGVSZXNwb25zZSh1cmwsIHF1ZXJ5LCB2b2lkIDAsIGZldGNoT3B0aW9ucyk7XG5cdH1cblx0YXN5bmMgZ2V0QWxsKHNsdWcsIHBhcmFtcyA9IHt9LCBlbnRpdHksIGZldGNoT3B0aW9ucykge1xuXHRcdGNvbnN0IHBlclBhZ2UgPSBwYXJhbXM/LnBlcl9wYWdlIHx8IDI1O1xuXHRcdGNvbnN0IHVybCA9IGAvJHtzbHVnfWAucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuXHRcdGNvbnN0IGUgPSBlbnRpdHkgPz8gdXJsLnN1YnN0cmluZyh1cmwubGFzdEluZGV4T2YoXCIvXCIpICsgMSk7XG5cdFx0cGFyYW1zLnZlcnNpb24gPSBwYXJhbXMudmVyc2lvbiB8fCB0aGlzLnZlcnNpb247XG5cdFx0Y29uc3QgZmlyc3RQYWdlID0gMTtcblx0XHRjb25zdCBmaXJzdFJlcyA9IGF3YWl0IHRoaXMubWFrZVJlcXVlc3QodXJsLCBwYXJhbXMsIHBlclBhZ2UsIGZpcnN0UGFnZSwgZmV0Y2hPcHRpb25zKTtcblx0XHRjb25zdCBsYXN0UGFnZSA9IGZpcnN0UmVzLnRvdGFsID8gTWF0aC5jZWlsKGZpcnN0UmVzLnRvdGFsIC8gKGZpcnN0UmVzLnBlclBhZ2UgfHwgcGVyUGFnZSkpIDogMTtcblx0XHRjb25zdCByZXN0UmVzID0gYXdhaXQgYXN5bmNNYXAocmFuZ2UoZmlyc3RQYWdlLCBsYXN0UGFnZSksIChpKSA9PiB7XG5cdFx0XHRyZXR1cm4gdGhpcy5tYWtlUmVxdWVzdCh1cmwsIHBhcmFtcywgcGVyUGFnZSwgaSArIDEsIGZldGNoT3B0aW9ucyk7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIGZsYXRNYXAoW2ZpcnN0UmVzLCAuLi5yZXN0UmVzXSwgKHJlcykgPT4gT2JqZWN0LnZhbHVlcyhyZXMuZGF0YVtlXSkpO1xuXHR9XG5cdHBvc3Qoc2x1ZywgcGFyYW1zID0ge30sIGZldGNoT3B0aW9ucykge1xuXHRcdGNvbnN0IHVybCA9IGAvJHtzbHVnfWA7XG5cdFx0cmV0dXJuIHRoaXMudGhyb3R0bGUoXCJwb3N0XCIsIHVybCwgcGFyYW1zLCBmZXRjaE9wdGlvbnMpO1xuXHR9XG5cdHB1dChzbHVnLCBwYXJhbXMgPSB7fSwgZmV0Y2hPcHRpb25zKSB7XG5cdFx0Y29uc3QgdXJsID0gYC8ke3NsdWd9YDtcblx0XHRyZXR1cm4gdGhpcy50aHJvdHRsZShcInB1dFwiLCB1cmwsIHBhcmFtcywgZmV0Y2hPcHRpb25zKTtcblx0fVxuXHRkZWxldGUoc2x1ZywgcGFyYW1zID0ge30sIGZldGNoT3B0aW9ucykge1xuXHRcdGlmICghcGFyYW1zKSBwYXJhbXMgPSB7fTtcblx0XHRjb25zdCB1cmwgPSBgLyR7c2x1Z31gO1xuXHRcdHJldHVybiB0aGlzLnRocm90dGxlKFwiZGVsZXRlXCIsIHVybCwgcGFyYW1zLCBmZXRjaE9wdGlvbnMpO1xuXHR9XG5cdGdldFN0b3JpZXMocGFyYW1zID0ge30sIGZldGNoT3B0aW9ucykge1xuXHRcdHRoaXMuX2FkZFJlc29sdmVMZXZlbChwYXJhbXMpO1xuXHRcdHJldHVybiB0aGlzLmdldChcImNkbi9zdG9yaWVzXCIsIHBhcmFtcywgZmV0Y2hPcHRpb25zKTtcblx0fVxuXHRnZXRTdG9yeShzbHVnLCBwYXJhbXMgPSB7fSwgZmV0Y2hPcHRpb25zKSB7XG5cdFx0dGhpcy5fYWRkUmVzb2x2ZUxldmVsKHBhcmFtcyk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0KGBjZG4vc3Rvcmllcy8ke3NsdWd9YCwgcGFyYW1zLCBmZXRjaE9wdGlvbnMpO1xuXHR9XG5cdGdldFRva2VuKCkge1xuXHRcdHJldHVybiB0aGlzLmFjY2Vzc1Rva2VuO1xuXHR9XG5cdGVqZWN0SW50ZXJjZXB0b3IoKSB7XG5cdFx0dGhpcy5jbGllbnQuZWplY3QoKTtcblx0fVxuXHRfYWRkUmVzb2x2ZUxldmVsKHBhcmFtcykge1xuXHRcdGlmICh0eXBlb2YgcGFyYW1zLnJlc29sdmVfcmVsYXRpb25zICE9PSBcInVuZGVmaW5lZFwiKSBwYXJhbXMucmVzb2x2ZV9sZXZlbCA9IDI7XG5cdH1cblx0X2NsZWFuQ29weSh2YWx1ZSkge1xuXHRcdHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG5cdH1cblx0X2luc2VydExpbmtzKGp0cmVlLCB0cmVlSXRlbSwgcmVzb2x2ZUlkKSB7XG5cdFx0Y29uc3Qgbm9kZSA9IGp0cmVlW3RyZWVJdGVtXTtcblx0XHRpZiAobm9kZSAmJiBub2RlLmZpZWxkdHlwZSA9PT0gXCJtdWx0aWxpbmtcIiAmJiBub2RlLmxpbmt0eXBlID09PSBcInN0b3J5XCIgJiYgdHlwZW9mIG5vZGUuaWQgPT09IFwic3RyaW5nXCIgJiYgdGhpcy5saW5rc1tyZXNvbHZlSWRdW25vZGUuaWRdKSBub2RlLnN0b3J5ID0gdGhpcy5fY2xlYW5Db3B5KHRoaXMubGlua3NbcmVzb2x2ZUlkXVtub2RlLmlkXSk7XG5cdFx0ZWxzZSBpZiAobm9kZSAmJiBub2RlLmxpbmt0eXBlID09PSBcInN0b3J5XCIgJiYgdHlwZW9mIG5vZGUudXVpZCA9PT0gXCJzdHJpbmdcIiAmJiB0aGlzLmxpbmtzW3Jlc29sdmVJZF1bbm9kZS51dWlkXSkgbm9kZS5zdG9yeSA9IHRoaXMuX2NsZWFuQ29weSh0aGlzLmxpbmtzW3Jlc29sdmVJZF1bbm9kZS51dWlkXSk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAcGFyYW0gcmVzb2x2ZUlkIEEgY291bnRlciBudW1iZXIgYXMgYSBzdHJpbmdcblx0KiBAcGFyYW0gdXVpZCBUaGUgdXVpZCBvZiB0aGUgc3Rvcnlcblx0KiBAcmV0dXJucyBzdHJpbmcgfCBvYmplY3Rcblx0Ki9cblx0Z2V0U3RvcnlSZWZlcmVuY2UocmVzb2x2ZUlkLCB1dWlkKSB7XG5cdFx0Y29uc3QgcmVzdWx0ID0gdGhpcy5yZWxhdGlvbnNbcmVzb2x2ZUlkXVt1dWlkXSA/IEpTT04ucGFyc2UodGhpcy5zdHJpbmdpZmllZFN0b3JpZXNDYWNoZVt1dWlkXSB8fCBKU09OLnN0cmluZ2lmeSh0aGlzLnJlbGF0aW9uc1tyZXNvbHZlSWRdW3V1aWRdKSkgOiB1dWlkO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblx0LyoqXG5cdCogUmVzb2x2ZXMgYSBmaWVsZCdzIHZhbHVlIGJ5IHJlcGxhY2luZyBVVUlEcyB3aXRoIHRoZWlyIGNvcnJlc3BvbmRpbmcgc3RvcnkgcmVmZXJlbmNlc1xuXHQqIEBwYXJhbSBqdHJlZSAtIFRoZSBKU09OIHRyZWUgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZpZWxkIHRvIHJlc29sdmVcblx0KiBAcGFyYW0gdHJlZUl0ZW0gLSBUaGUga2V5IG9mIHRoZSBmaWVsZCB0byByZXNvbHZlXG5cdCogQHBhcmFtIHJlc29sdmVJZCAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGN1cnJlbnQgcmVzb2x1dGlvbiBjb250ZXh0XG5cdCpcblx0KiBUaGlzIG1ldGhvZCBoYW5kbGVzIGJvdGggc2luZ2xlIHN0cmluZyBVVUlEcyBhbmQgYXJyYXlzIG9mIFVVSURzOlxuXHQqIC0gRm9yIHNpbmdsZSBzdHJpbmdzOiBkaXJlY3RseSByZXBsYWNlcyB0aGUgVVVJRCB3aXRoIHRoZSBzdG9yeSByZWZlcmVuY2Vcblx0KiAtIEZvciBhcnJheXM6IG1hcHMgdGhyb3VnaCBlYWNoIFVVSUQgYW5kIHJlcGxhY2VzIHdpdGggY29ycmVzcG9uZGluZyBzdG9yeSByZWZlcmVuY2VzXG5cdCovXG5cdF9yZXNvbHZlRmllbGQoanRyZWUsIHRyZWVJdGVtLCByZXNvbHZlSWQpIHtcblx0XHRjb25zdCBpdGVtID0ganRyZWVbdHJlZUl0ZW1dO1xuXHRcdGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIikganRyZWVbdHJlZUl0ZW1dID0gdGhpcy5nZXRTdG9yeVJlZmVyZW5jZShyZXNvbHZlSWQsIGl0ZW0pO1xuXHRcdGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIGp0cmVlW3RyZWVJdGVtXSA9IGl0ZW0ubWFwKCh1dWlkKSA9PiB0aGlzLmdldFN0b3J5UmVmZXJlbmNlKHJlc29sdmVJZCwgdXVpZCkpLmZpbHRlcihCb29sZWFuKTtcblx0fVxuXHQvKipcblx0KiBJbnNlcnRzIHJlbGF0aW9ucyBpbnRvIHRoZSBKU09OIHRyZWUgYnkgcmVzb2x2aW5nIHJlZmVyZW5jZXNcblx0KiBAcGFyYW0ganRyZWUgLSBUaGUgSlNPTiB0cmVlIG9iamVjdCB0byBwcm9jZXNzXG5cdCogQHBhcmFtIHRyZWVJdGVtIC0gVGhlIGN1cnJlbnQgZmllbGQgYmVpbmcgcHJvY2Vzc2VkXG5cdCogQHBhcmFtIGZpZWxkcyAtIFRoZSByZWxhdGlvbiBwYXR0ZXJucyB0byByZXNvbHZlIChzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncylcblx0KiBAcGFyYW0gcmVzb2x2ZUlkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgY3VycmVudCByZXNvbHV0aW9uIGNvbnRleHRcblx0KlxuXHQqIFRoaXMgbWV0aG9kIGhhbmRsZXMgdHdvIHR5cGVzIG9mIHJlbGF0aW9uIHBhdHRlcm5zOlxuXHQqIDEuIE5lc3RlZCByZWxhdGlvbnM6IG1hdGNoZXMgZmllbGRzIHRoYXQgZW5kIHdpdGggdGhlIGN1cnJlbnQgZmllbGQgbmFtZVxuXHQqICAgIEV4YW1wbGU6IElmIHRyZWVJdGVtIGlzIFwiZXZlbnRfdHlwZVwiLCBpdCBtYXRjaGVzIHBhdHRlcm5zIGxpa2UgXCIqLmV2ZW50X3R5cGVcIlxuXHQqXG5cdCogMi4gRGlyZWN0IGNvbXBvbmVudCByZWxhdGlvbnM6IG1hdGNoZXMgZXhhY3QgY29tcG9uZW50LmZpZWxkIHBhdHRlcm5zXG5cdCogICAgRXhhbXBsZTogXCJldmVudC5ldmVudF90eXBlXCIgZm9yIGNvbXBvbmVudCBcImV2ZW50XCIgYW5kIGZpZWxkIFwiZXZlbnRfdHlwZVwiXG5cdCpcblx0KiBUaGUgbWV0aG9kIHN1cHBvcnRzIGJvdGggc3RyaW5nIGFuZCBhcnJheSBmb3JtYXRzIGZvciB0aGUgZmllbGRzIHBhcmFtZXRlcixcblx0KiBhbGxvd2luZyBmbGV4aWJsZSBzcGVjaWZpY2F0aW9uIG9mIHJlbGF0aW9uIHBhdHRlcm5zLlxuXHQqL1xuXHRfaW5zZXJ0UmVsYXRpb25zKGp0cmVlLCB0cmVlSXRlbSwgZmllbGRzLCByZXNvbHZlSWQpIHtcblx0XHRjb25zdCBmaWVsZFBhdHRlcm4gPSBBcnJheS5pc0FycmF5KGZpZWxkcykgPyBmaWVsZHMuZmluZCgoZikgPT4gZi5lbmRzV2l0aChgLiR7dHJlZUl0ZW19YCkpIDogZmllbGRzLmVuZHNXaXRoKGAuJHt0cmVlSXRlbX1gKTtcblx0XHRpZiAoZmllbGRQYXR0ZXJuKSB7XG5cdFx0XHR0aGlzLl9yZXNvbHZlRmllbGQoanRyZWUsIHRyZWVJdGVtLCByZXNvbHZlSWQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRjb25zdCBmaWVsZFBhdGggPSBqdHJlZS5jb21wb25lbnQgPyBgJHtqdHJlZS5jb21wb25lbnR9LiR7dHJlZUl0ZW19YCA6IHRyZWVJdGVtO1xuXHRcdGlmIChBcnJheS5pc0FycmF5KGZpZWxkcykgPyBmaWVsZHMuaW5jbHVkZXMoZmllbGRQYXRoKSA6IGZpZWxkcyA9PT0gZmllbGRQYXRoKSB0aGlzLl9yZXNvbHZlRmllbGQoanRyZWUsIHRyZWVJdGVtLCByZXNvbHZlSWQpO1xuXHR9XG5cdC8qKlxuXHQqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlcyBhbmQgcmVzb2x2ZXMgcmVsYXRpb25zIGluIHRoZSBzdG9yeSBjb250ZW50IHRyZWVcblx0KiBAcGFyYW0gc3RvcnkgLSBUaGUgc3Rvcnkgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNvbnRlbnQgdG8gcHJvY2Vzc1xuXHQqIEBwYXJhbSBmaWVsZHMgLSBUaGUgcmVsYXRpb24gcGF0dGVybnMgdG8gcmVzb2x2ZVxuXHQqIEBwYXJhbSByZXNvbHZlSWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBjdXJyZW50IHJlc29sdXRpb24gY29udGV4dFxuXHQqL1xuXHRpdGVyYXRlVHJlZShzdG9yeSwgZmllbGRzLCByZXNvbHZlSWQpIHtcblx0XHRjb25zdCBlbnJpY2ggPSAoanRyZWUsIHBhdGggPSBcIlwiKSA9PiB7XG5cdFx0XHRpZiAoIWp0cmVlIHx8IGp0cmVlLl9zdG9wUmVzb2x2aW5nKSByZXR1cm47XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShqdHJlZSkpIGp0cmVlLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiBlbnJpY2goaXRlbSwgYCR7cGF0aH1bJHtpbmRleH1dYCkpO1xuXHRcdFx0ZWxzZSBpZiAodHlwZW9mIGp0cmVlID09PSBcIm9iamVjdFwiKSBmb3IgKGNvbnN0IGtleSBpbiBqdHJlZSkge1xuXHRcdFx0XHRjb25zdCBuZXdQYXRoID0gcGF0aCA/IGAke3BhdGh9LiR7a2V5fWAgOiBrZXk7XG5cdFx0XHRcdGlmIChqdHJlZS5jb21wb25lbnQgJiYganRyZWUuX3VpZCB8fCBqdHJlZS50eXBlID09PSBcImxpbmtcIikge1xuXHRcdFx0XHRcdHRoaXMuX2luc2VydFJlbGF0aW9ucyhqdHJlZSwga2V5LCBmaWVsZHMsIHJlc29sdmVJZCk7XG5cdFx0XHRcdFx0dGhpcy5faW5zZXJ0TGlua3MoanRyZWUsIGtleSwgcmVzb2x2ZUlkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbnJpY2goanRyZWVba2V5XSwgbmV3UGF0aCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRlbnJpY2goc3RvcnkuY29udGVudCk7XG5cdH1cblx0YXN5bmMgcmVzb2x2ZUxpbmtzKHJlc3BvbnNlRGF0YSwgcGFyYW1zLCByZXNvbHZlSWQpIHtcblx0XHRsZXQgbGlua3MgPSBbXTtcblx0XHRpZiAocmVzcG9uc2VEYXRhLmxpbmtfdXVpZHMpIHtcblx0XHRcdGNvbnN0IHJlbFNpemUgPSByZXNwb25zZURhdGEubGlua191dWlkcy5sZW5ndGg7XG5cdFx0XHRjb25zdCBjaHVua3MgPSBbXTtcblx0XHRcdGNvbnN0IGNodW5rU2l6ZSA9IDUwO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByZWxTaXplOyBpICs9IGNodW5rU2l6ZSkge1xuXHRcdFx0XHRjb25zdCBlbmQgPSBNYXRoLm1pbihyZWxTaXplLCBpICsgY2h1bmtTaXplKTtcblx0XHRcdFx0Y2h1bmtzLnB1c2gocmVzcG9uc2VEYXRhLmxpbmtfdXVpZHMuc2xpY2UoaSwgZW5kKSk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKGxldCBjaHVua0luZGV4ID0gMDsgY2h1bmtJbmRleCA8IGNodW5rcy5sZW5ndGg7IGNodW5rSW5kZXgrKykge1xuXHRcdFx0XHRjb25zdCBsaW5rc1JlcyA9IGF3YWl0IHRoaXMuZ2V0U3Rvcmllcyh7XG5cdFx0XHRcdFx0cGVyX3BhZ2U6IGNodW5rU2l6ZSxcblx0XHRcdFx0XHRsYW5ndWFnZTogcGFyYW1zLmxhbmd1YWdlLFxuXHRcdFx0XHRcdHZlcnNpb246IHBhcmFtcy52ZXJzaW9uLFxuXHRcdFx0XHRcdHN0YXJ0c193aXRoOiBwYXJhbXMuc3RhcnRzX3dpdGgsXG5cdFx0XHRcdFx0YnlfdXVpZHM6IGNodW5rc1tjaHVua0luZGV4XS5qb2luKFwiLFwiKVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0bGlua3NSZXMuZGF0YS5zdG9yaWVzLmZvckVhY2goKHJlbCkgPT4ge1xuXHRcdFx0XHRcdGxpbmtzLnB1c2gocmVsKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGxpbmtzID0gcmVzcG9uc2VEYXRhLmxpbmtzO1xuXHRcdGxpbmtzLmZvckVhY2goKHN0b3J5KSA9PiB7XG5cdFx0XHR0aGlzLmxpbmtzW3Jlc29sdmVJZF1bc3RvcnkudXVpZF0gPSB7XG5cdFx0XHRcdC4uLnN0b3J5LFxuXHRcdFx0XHRfc3RvcFJlc29sdmluZzogdHJ1ZVxuXHRcdFx0fTtcblx0XHR9KTtcblx0fVxuXHRhc3luYyByZXNvbHZlUmVsYXRpb25zKHJlc3BvbnNlRGF0YSwgcGFyYW1zLCByZXNvbHZlSWQpIHtcblx0XHRsZXQgcmVsYXRpb25zID0gW107XG5cdFx0aWYgKHJlc3BvbnNlRGF0YS5yZWxfdXVpZHMpIHtcblx0XHRcdGNvbnN0IHJlbFNpemUgPSByZXNwb25zZURhdGEucmVsX3V1aWRzLmxlbmd0aDtcblx0XHRcdGNvbnN0IGNodW5rcyA9IFtdO1xuXHRcdFx0Y29uc3QgY2h1bmtTaXplID0gNTA7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHJlbFNpemU7IGkgKz0gY2h1bmtTaXplKSB7XG5cdFx0XHRcdGNvbnN0IGVuZCA9IE1hdGgubWluKHJlbFNpemUsIGkgKyBjaHVua1NpemUpO1xuXHRcdFx0XHRjaHVua3MucHVzaChyZXNwb25zZURhdGEucmVsX3V1aWRzLnNsaWNlKGksIGVuZCkpO1xuXHRcdFx0fVxuXHRcdFx0Zm9yIChsZXQgY2h1bmtJbmRleCA9IDA7IGNodW5rSW5kZXggPCBjaHVua3MubGVuZ3RoOyBjaHVua0luZGV4KyspIHtcblx0XHRcdFx0Y29uc3QgcmVsYXRpb25zUmVzID0gYXdhaXQgdGhpcy5nZXRTdG9yaWVzKHtcblx0XHRcdFx0XHRwZXJfcGFnZTogY2h1bmtTaXplLFxuXHRcdFx0XHRcdGxhbmd1YWdlOiBwYXJhbXMubGFuZ3VhZ2UsXG5cdFx0XHRcdFx0dmVyc2lvbjogcGFyYW1zLnZlcnNpb24sXG5cdFx0XHRcdFx0c3RhcnRzX3dpdGg6IHBhcmFtcy5zdGFydHNfd2l0aCxcblx0XHRcdFx0XHRieV91dWlkczogY2h1bmtzW2NodW5rSW5kZXhdLmpvaW4oXCIsXCIpLFxuXHRcdFx0XHRcdGV4Y2x1ZGluZ19maWVsZHM6IHBhcmFtcy5leGNsdWRpbmdfZmllbGRzXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZWxhdGlvbnNSZXMuZGF0YS5zdG9yaWVzLmZvckVhY2goKHJlbCkgPT4ge1xuXHRcdFx0XHRcdHJlbGF0aW9ucy5wdXNoKHJlbCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHJlbGF0aW9ucy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHJlc3BvbnNlRGF0YS5yZWxzID0gcmVsYXRpb25zO1xuXHRcdFx0XHRkZWxldGUgcmVzcG9uc2VEYXRhLnJlbF91dWlkcztcblx0XHRcdH1cblx0XHR9IGVsc2UgcmVsYXRpb25zID0gcmVzcG9uc2VEYXRhLnJlbHM7XG5cdFx0aWYgKHJlbGF0aW9ucyAmJiByZWxhdGlvbnMubGVuZ3RoID4gMCkgcmVsYXRpb25zLmZvckVhY2goKHN0b3J5KSA9PiB7XG5cdFx0XHR0aGlzLnJlbGF0aW9uc1tyZXNvbHZlSWRdW3N0b3J5LnV1aWRdID0ge1xuXHRcdFx0XHQuLi5zdG9yeSxcblx0XHRcdFx0X3N0b3BSZXNvbHZpbmc6IHRydWVcblx0XHRcdH07XG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAcGFyYW0gcmVzcG9uc2VEYXRhXG5cdCogQHBhcmFtIHBhcmFtc1xuXHQqIEBwYXJhbSByZXNvbHZlSWRcblx0KiBAZGVzY3JpcHRpb24gUmVzb2x2ZXMgdGhlIHJlbGF0aW9ucyBhbmQgbGlua3Mgb2YgdGhlIHN0b3JpZXNcblx0KiBAcmV0dXJucyBQcm9taXNlPHZvaWQ+XG5cdCpcblx0Ki9cblx0YXN5bmMgcmVzb2x2ZVN0b3JpZXMocmVzcG9uc2VEYXRhLCBwYXJhbXMsIHJlc29sdmVJZCkge1xuXHRcdGxldCByZWxhdGlvblBhcmFtcyA9IFtdO1xuXHRcdHRoaXMubGlua3NbcmVzb2x2ZUlkXSA9IHt9O1xuXHRcdHRoaXMucmVsYXRpb25zW3Jlc29sdmVJZF0gPSB7fTtcblx0XHRpZiAodHlwZW9mIHBhcmFtcy5yZXNvbHZlX3JlbGF0aW9ucyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwYXJhbXMucmVzb2x2ZV9yZWxhdGlvbnMubGVuZ3RoID4gMCkge1xuXHRcdFx0aWYgKHR5cGVvZiBwYXJhbXMucmVzb2x2ZV9yZWxhdGlvbnMgPT09IFwic3RyaW5nXCIpIHJlbGF0aW9uUGFyYW1zID0gcGFyYW1zLnJlc29sdmVfcmVsYXRpb25zLnNwbGl0KFwiLFwiKTtcblx0XHRcdGF3YWl0IHRoaXMucmVzb2x2ZVJlbGF0aW9ucyhyZXNwb25zZURhdGEsIHBhcmFtcywgcmVzb2x2ZUlkKTtcblx0XHR9XG5cdFx0aWYgKHBhcmFtcy5yZXNvbHZlX2xpbmtzICYmIFtcblx0XHRcdFwiMVwiLFxuXHRcdFx0XCJzdG9yeVwiLFxuXHRcdFx0XCJ1cmxcIixcblx0XHRcdFwibGlua1wiXG5cdFx0XS5pbmNsdWRlcyhwYXJhbXMucmVzb2x2ZV9saW5rcykgJiYgKHJlc3BvbnNlRGF0YS5saW5rcz8ubGVuZ3RoIHx8IHJlc3BvbnNlRGF0YS5saW5rX3V1aWRzPy5sZW5ndGgpKSBhd2FpdCB0aGlzLnJlc29sdmVMaW5rcyhyZXNwb25zZURhdGEsIHBhcmFtcywgcmVzb2x2ZUlkKTtcblx0XHRpZiAodGhpcy5yZXNvbHZlTmVzdGVkUmVsYXRpb25zKSBmb3IgKGNvbnN0IHJlbFV1aWQgaW4gdGhpcy5yZWxhdGlvbnNbcmVzb2x2ZUlkXSkgdGhpcy5pdGVyYXRlVHJlZSh0aGlzLnJlbGF0aW9uc1tyZXNvbHZlSWRdW3JlbFV1aWRdLCByZWxhdGlvblBhcmFtcywgcmVzb2x2ZUlkKTtcblx0XHRpZiAocmVzcG9uc2VEYXRhLnN0b3J5KSB0aGlzLml0ZXJhdGVUcmVlKHJlc3BvbnNlRGF0YS5zdG9yeSwgcmVsYXRpb25QYXJhbXMsIHJlc29sdmVJZCk7XG5cdFx0ZWxzZSByZXNwb25zZURhdGEuc3Rvcmllcy5mb3JFYWNoKChzdG9yeSkgPT4ge1xuXHRcdFx0dGhpcy5pdGVyYXRlVHJlZShzdG9yeSwgcmVsYXRpb25QYXJhbXMsIHJlc29sdmVJZCk7XG5cdFx0fSk7XG5cdFx0dGhpcy5zdHJpbmdpZmllZFN0b3JpZXNDYWNoZSA9IHt9O1xuXHRcdGRlbGV0ZSB0aGlzLmxpbmtzW3Jlc29sdmVJZF07XG5cdFx0ZGVsZXRlIHRoaXMucmVsYXRpb25zW3Jlc29sdmVJZF07XG5cdH1cblx0YXN5bmMgY2FjaGVSZXNwb25zZSh1cmwsIHBhcmFtcywgcmV0cmllcywgZmV0Y2hPcHRpb25zKSB7XG5cdFx0Y29uc3QgY2FjaGVLZXkgPSBzdHJpbmdpZnkoe1xuXHRcdFx0dXJsLFxuXHRcdFx0cGFyYW1zXG5cdFx0fSk7XG5cdFx0Y29uc3QgcHJvdmlkZXIgPSB0aGlzLmNhY2hlUHJvdmlkZXIoKTtcblx0XHRpZiAocGFyYW1zLnZlcnNpb24gPT09IFwicHVibGlzaGVkXCIgJiYgdXJsICE9PSBcIi9jZG4vc3BhY2VzL21lXCIpIHtcblx0XHRcdGNvbnN0IGNhY2hlID0gYXdhaXQgcHJvdmlkZXIuZ2V0KGNhY2hlS2V5KTtcblx0XHRcdGlmIChjYWNoZSkgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjYWNoZSk7XG5cdFx0fVxuXHRcdHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb25zdCByZXMgPSBhd2FpdCB0aGlzLnRocm90dGxlKFwiZ2V0XCIsIHVybCwgcGFyYW1zLCBmZXRjaE9wdGlvbnMpO1xuXHRcdFx0XHRpZiAocmVzLnN0YXR1cyAhPT0gMjAwKSByZXR1cm4gcmVqZWN0KHJlcyk7XG5cdFx0XHRcdGxldCByZXNwb25zZSA9IHtcblx0XHRcdFx0XHRkYXRhOiByZXMuZGF0YSxcblx0XHRcdFx0XHRoZWFkZXJzOiByZXMuaGVhZGVyc1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAocmVzLmhlYWRlcnM/LltcInBlci1wYWdlXCJdKSByZXNwb25zZSA9IE9iamVjdC5hc3NpZ24oe30sIHJlc3BvbnNlLCB7XG5cdFx0XHRcdFx0cGVyUGFnZTogcmVzLmhlYWRlcnNbXCJwZXItcGFnZVwiXSA/IE51bWJlci5wYXJzZUludChyZXMuaGVhZGVyc1tcInBlci1wYWdlXCJdKSA6IDAsXG5cdFx0XHRcdFx0dG90YWw6IHJlcy5oZWFkZXJzW1wicGVyLXBhZ2VcIl0gPyBOdW1iZXIucGFyc2VJbnQocmVzLmhlYWRlcnMudG90YWwpIDogMFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0aWYgKHJlc3BvbnNlLmRhdGEuc3RvcnkgfHwgcmVzcG9uc2UuZGF0YS5zdG9yaWVzKSB7XG5cdFx0XHRcdFx0Y29uc3QgcmVzb2x2ZUlkID0gdGhpcy5yZXNvbHZlQ291bnRlciA9ICsrdGhpcy5yZXNvbHZlQ291bnRlciAlIDFlMztcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnJlc29sdmVTdG9yaWVzKHJlc3BvbnNlLmRhdGEsIHBhcmFtcywgYCR7cmVzb2x2ZUlkfWApO1xuXHRcdFx0XHRcdHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcm9jZXNzSW5saW5lQXNzZXRzKHJlc3BvbnNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocGFyYW1zLnZlcnNpb24gPT09IFwicHVibGlzaGVkXCIgJiYgdXJsICE9PSBcIi9jZG4vc3BhY2VzL21lXCIpIGF3YWl0IHByb3ZpZGVyLnNldChjYWNoZUtleSwgcmVzcG9uc2UpO1xuXHRcdFx0XHRjb25zdCBpc0NhY2hlQ2xlYXJhYmxlID0gdGhpcy5jYWNoZS5jbGVhciA9PT0gXCJvbnByZXZpZXdcIiAmJiBwYXJhbXMudmVyc2lvbiA9PT0gXCJkcmFmdFwiIHx8IHRoaXMuY2FjaGUuY2xlYXIgPT09IFwiYXV0b1wiO1xuXHRcdFx0XHRpZiAocGFyYW1zLnRva2VuICYmIHJlc3BvbnNlLmRhdGEuY3YpIHtcblx0XHRcdFx0XHRpZiAoaXNDYWNoZUNsZWFyYWJsZSAmJiBjYWNoZVZlcnNpb25zW3BhcmFtcy50b2tlbl0gJiYgY2FjaGVWZXJzaW9uc1twYXJhbXMudG9rZW5dICE9PSByZXNwb25zZS5kYXRhLmN2KSBhd2FpdCB0aGlzLmZsdXNoQ2FjaGUoKTtcblx0XHRcdFx0XHRjYWNoZVZlcnNpb25zW3BhcmFtcy50b2tlbl0gPSByZXNwb25zZS5kYXRhLmN2O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZXNvbHZlKHJlc3BvbnNlKTtcblx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdGlmIChlcnJvci5yZXNwb25zZSAmJiBlcnJvci5zdGF0dXMgPT09IDQyOSkge1xuXHRcdFx0XHRcdHJldHJpZXMgPSB0eXBlb2YgcmV0cmllcyA9PT0gXCJ1bmRlZmluZWRcIiA/IDAgOiByZXRyaWVzICsgMTtcblx0XHRcdFx0XHRpZiAocmV0cmllcyA8IHRoaXMubWF4UmV0cmllcykge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coYEhpdCByYXRlIGxpbWl0LiBSZXRyeWluZyBpbiAke3RoaXMucmV0cmllc0RlbGF5IC8gMWUzfSBzZWNvbmRzLmApO1xuXHRcdFx0XHRcdFx0YXdhaXQgZGVsYXkodGhpcy5yZXRyaWVzRGVsYXkpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuY2FjaGVSZXNwb25zZSh1cmwsIHBhcmFtcywgcmV0cmllcykudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cdHRocm90dGxlZFJlcXVlc3QodHlwZSwgdXJsLCBwYXJhbXMsIGZldGNoT3B0aW9ucykge1xuXHRcdHRoaXMuY2xpZW50LnNldEZldGNoT3B0aW9ucyhmZXRjaE9wdGlvbnMpO1xuXHRcdHJldHVybiB0aGlzLmNsaWVudFt0eXBlXSh1cmwsIHBhcmFtcyk7XG5cdH1cblx0Y2FjaGVWZXJzaW9ucygpIHtcblx0XHRyZXR1cm4gY2FjaGVWZXJzaW9ucztcblx0fVxuXHRjYWNoZVZlcnNpb24oKSB7XG5cdFx0cmV0dXJuIGNhY2hlVmVyc2lvbnNbdGhpcy5hY2Nlc3NUb2tlbl07XG5cdH1cblx0c2V0Q2FjaGVWZXJzaW9uKGN2KSB7XG5cdFx0aWYgKHRoaXMuYWNjZXNzVG9rZW4pIGNhY2hlVmVyc2lvbnNbdGhpcy5hY2Nlc3NUb2tlbl0gPSBjdjtcblx0fVxuXHRjbGVhckNhY2hlVmVyc2lvbigpIHtcblx0XHRpZiAodGhpcy5hY2Nlc3NUb2tlbikgY2FjaGVWZXJzaW9uc1t0aGlzLmFjY2Vzc1Rva2VuXSA9IDA7XG5cdH1cblx0Y2FjaGVQcm92aWRlcigpIHtcblx0XHRzd2l0Y2ggKHRoaXMuY2FjaGUudHlwZSkge1xuXHRcdFx0Y2FzZSBcIm1lbW9yeVwiOiByZXR1cm4ge1xuXHRcdFx0XHRnZXQoa2V5KSB7XG5cdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShtZW1vcnlba2V5XSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGdldEFsbCgpIHtcblx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1lbW9yeSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNldChrZXksIGNvbnRlbnQpIHtcblx0XHRcdFx0XHRtZW1vcnlba2V5XSA9IGNvbnRlbnQ7XG5cdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSh2b2lkIDApO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRmbHVzaCgpIHtcblx0XHRcdFx0XHRtZW1vcnkgPSB7fTtcblx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZvaWQgMCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRjYXNlIFwiY3VzdG9tXCI6IGlmICh0aGlzLmNhY2hlLmN1c3RvbSkgcmV0dXJuIHRoaXMuY2FjaGUuY3VzdG9tO1xuXHRcdFx0ZGVmYXVsdDogcmV0dXJuIHtcblx0XHRcdFx0Z2V0KCkge1xuXHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0Z2V0QWxsKCkge1xuXHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUodm9pZCAwKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0c2V0KCkge1xuXHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUodm9pZCAwKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0Zmx1c2goKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSh2b2lkIDApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXHRhc3luYyBmbHVzaENhY2hlKCkge1xuXHRcdGF3YWl0IHRoaXMuY2FjaGVQcm92aWRlcigpLmZsdXNoKCk7XG5cdFx0dGhpcy5jbGVhckNhY2hlVmVyc2lvbigpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGFzeW5jIHByb2Nlc3NJbmxpbmVBc3NldHMocmVzcG9uc2UpIHtcblx0XHRpZiAoIXRoaXMuaW5saW5lQXNzZXRzKSByZXR1cm4gcmVzcG9uc2U7XG5cdFx0Y29uc3QgcHJvY2Vzc05vZGUgPSAobm9kZSkgPT4ge1xuXHRcdFx0aWYgKCFub2RlIHx8IHR5cGVvZiBub2RlICE9PSBcIm9iamVjdFwiKSByZXR1cm4gbm9kZTtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSByZXR1cm4gbm9kZS5tYXAoKGl0ZW0pID0+IHByb2Nlc3NOb2RlKGl0ZW0pKTtcblx0XHRcdGxldCBwcm9jZXNzZWROb2RlID0geyAuLi5ub2RlIH07XG5cdFx0XHRpZiAocHJvY2Vzc2VkTm9kZS5maWVsZHR5cGUgPT09IFwiYXNzZXRcIiAmJiBBcnJheS5pc0FycmF5KHJlc3BvbnNlLmRhdGEuYXNzZXRzKSkgcHJvY2Vzc2VkTm9kZSA9IHtcblx0XHRcdFx0Li4ucHJvY2Vzc2VkTm9kZSxcblx0XHRcdFx0Li4ucmVzcG9uc2UuZGF0YS5hc3NldHMuZmluZCgoYXNzZXQpID0+IGFzc2V0LmlkID09PSBwcm9jZXNzZWROb2RlLmlkKVxuXHRcdFx0fTtcblx0XHRcdGZvciAoY29uc3Qga2V5IGluIHByb2Nlc3NlZE5vZGUpIGlmICh0eXBlb2YgcHJvY2Vzc2VkTm9kZVtrZXldID09PSBcIm9iamVjdFwiKSBwcm9jZXNzZWROb2RlW2tleV0gPSBwcm9jZXNzTm9kZShwcm9jZXNzZWROb2RlW2tleV0pO1xuXHRcdFx0cmV0dXJuIHByb2Nlc3NlZE5vZGU7XG5cdFx0fTtcblx0XHRpZiAocmVzcG9uc2UuZGF0YS5zdG9yeSkgcmVzcG9uc2UuZGF0YS5zdG9yeS5jb250ZW50ID0gcHJvY2Vzc05vZGUocmVzcG9uc2UuZGF0YS5zdG9yeS5jb250ZW50KTtcblx0XHRpZiAocmVzcG9uc2UuZGF0YS5zdG9yaWVzKSByZXNwb25zZS5kYXRhLnN0b3JpZXMgPSByZXNwb25zZS5kYXRhLnN0b3JpZXMubWFwKChzdG9yeSkgPT4ge1xuXHRcdFx0c3RvcnkuY29udGVudCA9IHByb2Nlc3NOb2RlKHN0b3J5LmNvbnRlbnQpO1xuXHRcdFx0cmV0dXJuIHN0b3J5O1xuXHRcdH0pO1xuXHRcdHJldHVybiByZXNwb25zZTtcblx0fVxufTtcbnZhciBzcmNfZGVmYXVsdCA9IFN0b3J5YmxvaztcblxuLy8jZW5kcmVnaW9uXG5leHBvcnQgeyBTdG9yeWJsb2ssIHNyY19kZWZhdWx0IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/storyblok-js-client/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/storyblok-js-client/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/storyblok-js-client/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Storyblok: () => (/* binding */ Storyblok),\n/* harmony export */   \"default\": () => (/* binding */ src_default)\n/* harmony export */ });\n//#region src/throttlePromise.ts\nvar AbortError = class extends Error {\n\tconstructor(msg) {\n\t\tsuper(msg);\n\t\tthis.name = \"AbortError\";\n\t}\n};\nfunction throttledQueue(fn, limit, interval) {\n\tif (!Number.isFinite(limit)) throw new TypeError(\"Expected `limit` to be a finite number\");\n\tif (!Number.isFinite(interval)) throw new TypeError(\"Expected `interval` to be a finite number\");\n\tconst queue = [];\n\tlet timeouts = [];\n\tlet activeCount = 0;\n\tlet isAborted = false;\n\tconst next = async () => {\n\t\tactiveCount++;\n\t\tconst x = queue.shift();\n\t\tif (x) try {\n\t\t\tconst res = await fn(...x.args);\n\t\t\tx.resolve(res);\n\t\t} catch (error) {\n\t\t\tx.reject(error);\n\t\t}\n\t\tconst id = setTimeout(() => {\n\t\t\tactiveCount--;\n\t\t\tif (queue.length > 0) next();\n\t\t\ttimeouts = timeouts.filter((currentId) => currentId !== id);\n\t\t}, interval);\n\t\tif (!timeouts.includes(id)) timeouts.push(id);\n\t};\n\tconst throttled = (...args) => {\n\t\tif (isAborted) return Promise.reject(/* @__PURE__ */ new Error(\"Throttled function is already aborted and not accepting new promises\"));\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tqueue.push({\n\t\t\t\tresolve,\n\t\t\t\treject,\n\t\t\t\targs\n\t\t\t});\n\t\t\tif (activeCount < limit) next();\n\t\t});\n\t};\n\tthrottled.abort = () => {\n\t\tisAborted = true;\n\t\ttimeouts.forEach(clearTimeout);\n\t\ttimeouts = [];\n\t\tqueue.forEach((x) => x.reject(() => new AbortError(\"Throttle function aborted\")));\n\t\tqueue.length = 0;\n\t};\n\treturn throttled;\n}\nvar throttlePromise_default = throttledQueue;\n\n//#endregion\n//#region src/utils.ts\n/**\n* Checks if a URL is a CDN URL\n* @param url - The URL to check\n* @returns boolean indicating if the URL is a CDN URL\n*/\nconst isCDNUrl = (url = \"\") => url.includes(\"/cdn/\");\n/**\n* Gets pagination options for the API request\n* @param options - The base options\n* @param perPage - Number of items per page\n* @param page - Current page number\n* @returns Object with pagination options\n*/\nconst getOptionsPage = (options, perPage = 25, page = 1) => ({\n\t...options,\n\tper_page: perPage,\n\tpage\n});\n/**\n* Creates a promise that resolves after the specified milliseconds\n* @param ms - Milliseconds to delay\n* @returns Promise that resolves after the delay\n*/\nconst delay = (ms) => new Promise((res) => setTimeout(res, ms));\n/**\n* Creates an array of specified length using a mapping function\n* @param length - Length of the array\n* @param func - Mapping function\n* @returns Array of specified length\n*/\nconst arrayFrom = (length = 0, func) => Array.from({ length }, func);\n/**\n* Creates an array of numbers in the specified range\n* @param start - Start of the range\n* @param end - End of the range\n* @returns Array of numbers in the range\n*/\nconst range = (start = 0, end = start) => {\n\tconst length = Math.abs(end - start) || 0;\n\tconst step = start < end ? 1 : -1;\n\treturn arrayFrom(length, (_, i) => i * step + start);\n};\n/**\n* Maps an array asynchronously\n* @param arr - Array to map\n* @param func - Async mapping function\n* @returns Promise resolving to mapped array\n*/\nconst asyncMap = async (arr, func) => Promise.all(arr.map(func));\n/**\n* Flattens an array using a mapping function\n* @param arr - Array to flatten\n* @param func - Mapping function\n* @returns Flattened array\n*/\nconst flatMap = (arr = [], func) => arr.map(func).reduce((xs, ys) => [...xs, ...ys], []);\n/**\n* Stringifies an object into a URL query string\n* @param params - Parameters to stringify\n* @param prefix - Prefix for nested keys\n* @param isArray - Whether the current level is an array\n* @returns Stringified query parameters\n*/\nconst stringify = (params, prefix, isArray) => {\n\tconst pairs = [];\n\tfor (const key in params) {\n\t\tif (!Object.prototype.hasOwnProperty.call(params, key)) continue;\n\t\tconst value = params[key];\n\t\tif (value === null || value === void 0) continue;\n\t\tconst enkey = isArray ? \"\" : encodeURIComponent(key);\n\t\tlet pair;\n\t\tif (typeof value === \"object\") pair = stringify(value, prefix ? prefix + encodeURIComponent(`[${enkey}]`) : enkey, Array.isArray(value));\n\t\telse pair = `${prefix ? prefix + encodeURIComponent(`[${enkey}]`) : enkey}=${encodeURIComponent(value)}`;\n\t\tpairs.push(pair);\n\t}\n\treturn pairs.join(\"&\");\n};\n/**\n* Gets the base URL for a specific region\n* @param regionCode - Region code (eu, us, cn, ap, ca)\n* @returns Base URL for the region\n*/\nconst getRegionURL = (regionCode) => {\n\tconst REGION_URLS = {\n\t\teu: \"api.storyblok.com\",\n\t\tus: \"api-us.storyblok.com\",\n\t\tcn: \"app.storyblokchina.cn\",\n\t\tap: \"api-ap.storyblok.com\",\n\t\tca: \"api-ca.storyblok.com\"\n\t};\n\treturn REGION_URLS[regionCode] ?? REGION_URLS.eu;\n};\n\n//#endregion\n//#region src/sbFetch.ts\nvar SbFetch = class {\n\tbaseURL;\n\ttimeout;\n\theaders;\n\tresponseInterceptor;\n\tfetch;\n\tejectInterceptor;\n\turl;\n\tparameters;\n\tfetchOptions;\n\tconstructor($c) {\n\t\tthis.baseURL = $c.baseURL;\n\t\tthis.headers = $c.headers || new Headers();\n\t\tthis.timeout = $c?.timeout ? $c.timeout * 1e3 : 0;\n\t\tthis.responseInterceptor = $c.responseInterceptor;\n\t\tthis.fetch = (...args) => $c.fetch ? $c.fetch(...args) : fetch(...args);\n\t\tthis.ejectInterceptor = false;\n\t\tthis.url = \"\";\n\t\tthis.parameters = {};\n\t\tthis.fetchOptions = {};\n\t}\n\t/**\n\t*\n\t* @param url string\n\t* @param params ISbStoriesParams\n\t* @returns Promise<ISbResponse | Error>\n\t*/\n\tget(url, params) {\n\t\tthis.url = url;\n\t\tthis.parameters = params;\n\t\treturn this._methodHandler(\"get\");\n\t}\n\tpost(url, params) {\n\t\tthis.url = url;\n\t\tthis.parameters = params;\n\t\treturn this._methodHandler(\"post\");\n\t}\n\tput(url, params) {\n\t\tthis.url = url;\n\t\tthis.parameters = params;\n\t\treturn this._methodHandler(\"put\");\n\t}\n\tdelete(url, params) {\n\t\tthis.url = url;\n\t\tthis.parameters = params ?? {};\n\t\treturn this._methodHandler(\"delete\");\n\t}\n\tasync _responseHandler(res) {\n\t\tconst headers = [];\n\t\tconst response = {\n\t\t\tdata: {},\n\t\t\theaders: {},\n\t\t\tstatus: 0,\n\t\t\tstatusText: \"\"\n\t\t};\n\t\tif (res.status !== 204) await res.json().then(($r) => {\n\t\t\tresponse.data = $r;\n\t\t});\n\t\tfor (const pair of res.headers.entries()) headers[pair[0]] = pair[1];\n\t\tresponse.headers = { ...headers };\n\t\tresponse.status = res.status;\n\t\tresponse.statusText = res.statusText;\n\t\treturn response;\n\t}\n\tasync _methodHandler(method) {\n\t\tlet urlString = `${this.baseURL}${this.url}`;\n\t\tlet body = null;\n\t\tif (method === \"get\") urlString = `${this.baseURL}${this.url}?${stringify(this.parameters)}`;\n\t\telse body = JSON.stringify(this.parameters);\n\t\tconst url = new URL(urlString);\n\t\tconst controller = new AbortController();\n\t\tconst { signal } = controller;\n\t\tlet timeout;\n\t\tif (this.timeout) timeout = setTimeout(() => controller.abort(), this.timeout);\n\t\ttry {\n\t\t\tconst fetchResponse = await this.fetch(`${url}`, {\n\t\t\t\tmethod,\n\t\t\t\theaders: this.headers,\n\t\t\t\tbody,\n\t\t\t\tsignal,\n\t\t\t\t...this.fetchOptions\n\t\t\t});\n\t\t\tif (this.timeout) clearTimeout(timeout);\n\t\t\tconst response = await this._responseHandler(fetchResponse);\n\t\t\tif (this.responseInterceptor && !this.ejectInterceptor) return this._statusHandler(this.responseInterceptor(response));\n\t\t\telse return this._statusHandler(response);\n\t\t} catch (err) {\n\t\t\tconst error = { message: err };\n\t\t\treturn error;\n\t\t}\n\t}\n\tsetFetchOptions(fetchOptions = {}) {\n\t\tif (Object.keys(fetchOptions).length > 0 && \"method\" in fetchOptions) delete fetchOptions.method;\n\t\tthis.fetchOptions = { ...fetchOptions };\n\t}\n\teject() {\n\t\tthis.ejectInterceptor = true;\n\t}\n\t/**\n\t* Normalizes error messages from different response structures\n\t* @param data The response data that might contain error information\n\t* @returns A normalized error message string\n\t*/\n\t_normalizeErrorMessage(data) {\n\t\tif (Array.isArray(data)) return data[0] || \"Unknown error\";\n\t\tif (data && typeof data === \"object\") {\n\t\t\tif (data.error) return data.error;\n\t\t\tfor (const key in data) {\n\t\t\t\tif (Array.isArray(data[key])) return `${key}: ${data[key][0]}`;\n\t\t\t\tif (typeof data[key] === \"string\") return `${key}: ${data[key]}`;\n\t\t\t}\n\t\t\tif (data.slug) return data.slug;\n\t\t}\n\t\treturn \"Unknown error\";\n\t}\n\t_statusHandler(res) {\n\t\tconst statusOk = /20[0-6]/g;\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tif (statusOk.test(`${res.status}`)) return resolve(res);\n\t\t\tconst error = {\n\t\t\t\tmessage: this._normalizeErrorMessage(res.data),\n\t\t\t\tstatus: res.status,\n\t\t\t\tresponse: res\n\t\t\t};\n\t\t\treject(error);\n\t\t});\n\t}\n};\nvar sbFetch_default = SbFetch;\n\n//#endregion\n//#region src/constants.ts\nconst STORYBLOK_AGENT = \"SB-Agent\";\nconst STORYBLOK_JS_CLIENT_AGENT = {\n\tdefaultAgentName: \"SB-JS-CLIENT\",\n\tdefaultAgentVersion: \"SB-Agent-Version\",\n\tpackageVersion: \"7.0.0\"\n};\nconst StoryblokContentVersion = {\n\tDRAFT: \"draft\",\n\tPUBLISHED: \"published\"\n};\nconst StoryblokContentVersionValues = Object.values(StoryblokContentVersion);\n\n//#endregion\n//#region src/index.ts\nlet memory = {};\nconst cacheVersions = {};\nvar Storyblok = class {\n\tclient;\n\tmaxRetries;\n\tretriesDelay;\n\tthrottle;\n\taccessToken;\n\tcache;\n\tresolveCounter;\n\trelations;\n\tlinks;\n\tversion;\n\t/**\n\t* @deprecated This property is deprecated. Use the standalone `richTextResolver` from `@storyblok/richtext` instead.\n\t* @see https://github.com/storyblok/richtext\n\t*/\n\trichTextResolver;\n\tresolveNestedRelations;\n\tstringifiedStoriesCache;\n\tinlineAssets;\n\t/**\n\t*\n\t* @param config ISbConfig interface\n\t* @param pEndpoint string, optional\n\t*/\n\tconstructor(config, pEndpoint) {\n\t\tlet endpoint = config.endpoint || pEndpoint;\n\t\tif (!endpoint) {\n\t\t\tconst protocol = config.https === false ? \"http\" : \"https\";\n\t\t\tif (!config.oauthToken) endpoint = `${protocol}://${getRegionURL(config.region)}/v2`;\n\t\t\telse endpoint = `${protocol}://${getRegionURL(config.region)}/v1`;\n\t\t}\n\t\tconst headers = new Headers();\n\t\theaders.set(\"Content-Type\", \"application/json\");\n\t\theaders.set(\"Accept\", \"application/json\");\n\t\tif (config.headers) {\n\t\t\tconst entries = config.headers.constructor.name === \"Headers\" ? config.headers.entries().toArray() : Object.entries(config.headers);\n\t\t\tentries.forEach(([key, value]) => {\n\t\t\t\theaders.set(key, value);\n\t\t\t});\n\t\t}\n\t\tif (!headers.has(STORYBLOK_AGENT)) {\n\t\t\theaders.set(STORYBLOK_AGENT, STORYBLOK_JS_CLIENT_AGENT.defaultAgentName);\n\t\t\theaders.set(STORYBLOK_JS_CLIENT_AGENT.defaultAgentVersion, STORYBLOK_JS_CLIENT_AGENT.packageVersion);\n\t\t}\n\t\tlet rateLimit = 5;\n\t\tif (config.oauthToken) {\n\t\t\theaders.set(\"Authorization\", config.oauthToken);\n\t\t\trateLimit = 3;\n\t\t}\n\t\tif (config.rateLimit) rateLimit = config.rateLimit;\n\t\tthis.maxRetries = config.maxRetries || 10;\n\t\tthis.retriesDelay = 300;\n\t\tthis.throttle = throttlePromise_default(this.throttledRequest.bind(this), rateLimit, 1e3);\n\t\tthis.accessToken = config.accessToken || \"\";\n\t\tthis.relations = {};\n\t\tthis.links = {};\n\t\tthis.cache = config.cache || { clear: \"manual\" };\n\t\tthis.resolveCounter = 0;\n\t\tthis.resolveNestedRelations = config.resolveNestedRelations || true;\n\t\tthis.stringifiedStoriesCache = {};\n\t\tthis.version = config.version || StoryblokContentVersion.PUBLISHED;\n\t\tthis.inlineAssets = config.inlineAssets || false;\n\t\tthis.client = new sbFetch_default({\n\t\t\tbaseURL: endpoint,\n\t\t\ttimeout: config.timeout || 0,\n\t\t\theaders,\n\t\t\tresponseInterceptor: config.responseInterceptor,\n\t\t\tfetch: config.fetch\n\t\t});\n\t}\n\tparseParams(params) {\n\t\tif (!params.token) params.token = this.getToken();\n\t\tif (!params.cv) params.cv = cacheVersions[params.token];\n\t\tif (Array.isArray(params.resolve_relations)) params.resolve_relations = params.resolve_relations.join(\",\");\n\t\tif (typeof params.resolve_relations !== \"undefined\") params.resolve_level = 2;\n\t\treturn params;\n\t}\n\tfactoryParamOptions(url, params) {\n\t\tif (isCDNUrl(url)) return this.parseParams(params);\n\t\treturn params;\n\t}\n\tmakeRequest(url, params, per_page, page, fetchOptions) {\n\t\tconst query = this.factoryParamOptions(url, getOptionsPage(params, per_page, page));\n\t\treturn this.cacheResponse(url, query, void 0, fetchOptions);\n\t}\n\tget(slug, params = {}, fetchOptions) {\n\t\tif (!params) params = {};\n\t\tconst url = `/${slug}`;\n\t\tif (isCDNUrl(url)) params.version = params.version || this.version;\n\t\tconst query = this.factoryParamOptions(url, params);\n\t\treturn this.cacheResponse(url, query, void 0, fetchOptions);\n\t}\n\tasync getAll(slug, params = {}, entity, fetchOptions) {\n\t\tconst perPage = params?.per_page || 25;\n\t\tconst url = `/${slug}`.replace(/\\/$/, \"\");\n\t\tconst e = entity ?? url.substring(url.lastIndexOf(\"/\") + 1);\n\t\tparams.version = params.version || this.version;\n\t\tconst firstPage = 1;\n\t\tconst firstRes = await this.makeRequest(url, params, perPage, firstPage, fetchOptions);\n\t\tconst lastPage = firstRes.total ? Math.ceil(firstRes.total / (firstRes.perPage || perPage)) : 1;\n\t\tconst restRes = await asyncMap(range(firstPage, lastPage), (i) => {\n\t\t\treturn this.makeRequest(url, params, perPage, i + 1, fetchOptions);\n\t\t});\n\t\treturn flatMap([firstRes, ...restRes], (res) => Object.values(res.data[e]));\n\t}\n\tpost(slug, params = {}, fetchOptions) {\n\t\tconst url = `/${slug}`;\n\t\treturn this.throttle(\"post\", url, params, fetchOptions);\n\t}\n\tput(slug, params = {}, fetchOptions) {\n\t\tconst url = `/${slug}`;\n\t\treturn this.throttle(\"put\", url, params, fetchOptions);\n\t}\n\tdelete(slug, params = {}, fetchOptions) {\n\t\tif (!params) params = {};\n\t\tconst url = `/${slug}`;\n\t\treturn this.throttle(\"delete\", url, params, fetchOptions);\n\t}\n\tgetStories(params = {}, fetchOptions) {\n\t\tthis._addResolveLevel(params);\n\t\treturn this.get(\"cdn/stories\", params, fetchOptions);\n\t}\n\tgetStory(slug, params = {}, fetchOptions) {\n\t\tthis._addResolveLevel(params);\n\t\treturn this.get(`cdn/stories/${slug}`, params, fetchOptions);\n\t}\n\tgetToken() {\n\t\treturn this.accessToken;\n\t}\n\tejectInterceptor() {\n\t\tthis.client.eject();\n\t}\n\t_addResolveLevel(params) {\n\t\tif (typeof params.resolve_relations !== \"undefined\") params.resolve_level = 2;\n\t}\n\t_cleanCopy(value) {\n\t\treturn JSON.parse(JSON.stringify(value));\n\t}\n\t_insertLinks(jtree, treeItem, resolveId) {\n\t\tconst node = jtree[treeItem];\n\t\tif (node && node.fieldtype === \"multilink\" && node.linktype === \"story\" && typeof node.id === \"string\" && this.links[resolveId][node.id]) node.story = this._cleanCopy(this.links[resolveId][node.id]);\n\t\telse if (node && node.linktype === \"story\" && typeof node.uuid === \"string\" && this.links[resolveId][node.uuid]) node.story = this._cleanCopy(this.links[resolveId][node.uuid]);\n\t}\n\t/**\n\t*\n\t* @param resolveId A counter number as a string\n\t* @param uuid The uuid of the story\n\t* @returns string | object\n\t*/\n\tgetStoryReference(resolveId, uuid) {\n\t\tconst result = this.relations[resolveId][uuid] ? JSON.parse(this.stringifiedStoriesCache[uuid] || JSON.stringify(this.relations[resolveId][uuid])) : uuid;\n\t\treturn result;\n\t}\n\t/**\n\t* Resolves a field's value by replacing UUIDs with their corresponding story references\n\t* @param jtree - The JSON tree object containing the field to resolve\n\t* @param treeItem - The key of the field to resolve\n\t* @param resolveId - The unique identifier for the current resolution context\n\t*\n\t* This method handles both single string UUIDs and arrays of UUIDs:\n\t* - For single strings: directly replaces the UUID with the story reference\n\t* - For arrays: maps through each UUID and replaces with corresponding story references\n\t*/\n\t_resolveField(jtree, treeItem, resolveId) {\n\t\tconst item = jtree[treeItem];\n\t\tif (typeof item === \"string\") jtree[treeItem] = this.getStoryReference(resolveId, item);\n\t\telse if (Array.isArray(item)) jtree[treeItem] = item.map((uuid) => this.getStoryReference(resolveId, uuid)).filter(Boolean);\n\t}\n\t/**\n\t* Inserts relations into the JSON tree by resolving references\n\t* @param jtree - The JSON tree object to process\n\t* @param treeItem - The current field being processed\n\t* @param fields - The relation patterns to resolve (string or array of strings)\n\t* @param resolveId - The unique identifier for the current resolution context\n\t*\n\t* This method handles two types of relation patterns:\n\t* 1. Nested relations: matches fields that end with the current field name\n\t*    Example: If treeItem is \"event_type\", it matches patterns like \"*.event_type\"\n\t*\n\t* 2. Direct component relations: matches exact component.field patterns\n\t*    Example: \"event.event_type\" for component \"event\" and field \"event_type\"\n\t*\n\t* The method supports both string and array formats for the fields parameter,\n\t* allowing flexible specification of relation patterns.\n\t*/\n\t_insertRelations(jtree, treeItem, fields, resolveId) {\n\t\tconst fieldPattern = Array.isArray(fields) ? fields.find((f) => f.endsWith(`.${treeItem}`)) : fields.endsWith(`.${treeItem}`);\n\t\tif (fieldPattern) {\n\t\t\tthis._resolveField(jtree, treeItem, resolveId);\n\t\t\treturn;\n\t\t}\n\t\tconst fieldPath = jtree.component ? `${jtree.component}.${treeItem}` : treeItem;\n\t\tif (Array.isArray(fields) ? fields.includes(fieldPath) : fields === fieldPath) this._resolveField(jtree, treeItem, resolveId);\n\t}\n\t/**\n\t* Recursively traverses and resolves relations in the story content tree\n\t* @param story - The story object containing the content to process\n\t* @param fields - The relation patterns to resolve\n\t* @param resolveId - The unique identifier for the current resolution context\n\t*/\n\titerateTree(story, fields, resolveId) {\n\t\tconst enrich = (jtree, path = \"\") => {\n\t\t\tif (!jtree || jtree._stopResolving) return;\n\t\t\tif (Array.isArray(jtree)) jtree.forEach((item, index) => enrich(item, `${path}[${index}]`));\n\t\t\telse if (typeof jtree === \"object\") for (const key in jtree) {\n\t\t\t\tconst newPath = path ? `${path}.${key}` : key;\n\t\t\t\tif (jtree.component && jtree._uid || jtree.type === \"link\") {\n\t\t\t\t\tthis._insertRelations(jtree, key, fields, resolveId);\n\t\t\t\t\tthis._insertLinks(jtree, key, resolveId);\n\t\t\t\t}\n\t\t\t\tenrich(jtree[key], newPath);\n\t\t\t}\n\t\t};\n\t\tenrich(story.content);\n\t}\n\tasync resolveLinks(responseData, params, resolveId) {\n\t\tlet links = [];\n\t\tif (responseData.link_uuids) {\n\t\t\tconst relSize = responseData.link_uuids.length;\n\t\t\tconst chunks = [];\n\t\t\tconst chunkSize = 50;\n\t\t\tfor (let i = 0; i < relSize; i += chunkSize) {\n\t\t\t\tconst end = Math.min(relSize, i + chunkSize);\n\t\t\t\tchunks.push(responseData.link_uuids.slice(i, end));\n\t\t\t}\n\t\t\tfor (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {\n\t\t\t\tconst linksRes = await this.getStories({\n\t\t\t\t\tper_page: chunkSize,\n\t\t\t\t\tlanguage: params.language,\n\t\t\t\t\tversion: params.version,\n\t\t\t\t\tstarts_with: params.starts_with,\n\t\t\t\t\tby_uuids: chunks[chunkIndex].join(\",\")\n\t\t\t\t});\n\t\t\t\tlinksRes.data.stories.forEach((rel) => {\n\t\t\t\t\tlinks.push(rel);\n\t\t\t\t});\n\t\t\t}\n\t\t} else links = responseData.links;\n\t\tlinks.forEach((story) => {\n\t\t\tthis.links[resolveId][story.uuid] = {\n\t\t\t\t...story,\n\t\t\t\t_stopResolving: true\n\t\t\t};\n\t\t});\n\t}\n\tasync resolveRelations(responseData, params, resolveId) {\n\t\tlet relations = [];\n\t\tif (responseData.rel_uuids) {\n\t\t\tconst relSize = responseData.rel_uuids.length;\n\t\t\tconst chunks = [];\n\t\t\tconst chunkSize = 50;\n\t\t\tfor (let i = 0; i < relSize; i += chunkSize) {\n\t\t\t\tconst end = Math.min(relSize, i + chunkSize);\n\t\t\t\tchunks.push(responseData.rel_uuids.slice(i, end));\n\t\t\t}\n\t\t\tfor (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {\n\t\t\t\tconst relationsRes = await this.getStories({\n\t\t\t\t\tper_page: chunkSize,\n\t\t\t\t\tlanguage: params.language,\n\t\t\t\t\tversion: params.version,\n\t\t\t\t\tstarts_with: params.starts_with,\n\t\t\t\t\tby_uuids: chunks[chunkIndex].join(\",\"),\n\t\t\t\t\texcluding_fields: params.excluding_fields\n\t\t\t\t});\n\t\t\t\trelationsRes.data.stories.forEach((rel) => {\n\t\t\t\t\trelations.push(rel);\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (relations.length > 0) {\n\t\t\t\tresponseData.rels = relations;\n\t\t\t\tdelete responseData.rel_uuids;\n\t\t\t}\n\t\t} else relations = responseData.rels;\n\t\tif (relations && relations.length > 0) relations.forEach((story) => {\n\t\t\tthis.relations[resolveId][story.uuid] = {\n\t\t\t\t...story,\n\t\t\t\t_stopResolving: true\n\t\t\t};\n\t\t});\n\t}\n\t/**\n\t*\n\t* @param responseData\n\t* @param params\n\t* @param resolveId\n\t* @description Resolves the relations and links of the stories\n\t* @returns Promise<void>\n\t*\n\t*/\n\tasync resolveStories(responseData, params, resolveId) {\n\t\tlet relationParams = [];\n\t\tthis.links[resolveId] = {};\n\t\tthis.relations[resolveId] = {};\n\t\tif (typeof params.resolve_relations !== \"undefined\" && params.resolve_relations.length > 0) {\n\t\t\tif (typeof params.resolve_relations === \"string\") relationParams = params.resolve_relations.split(\",\");\n\t\t\tawait this.resolveRelations(responseData, params, resolveId);\n\t\t}\n\t\tif (params.resolve_links && [\n\t\t\t\"1\",\n\t\t\t\"story\",\n\t\t\t\"url\",\n\t\t\t\"link\"\n\t\t].includes(params.resolve_links) && (responseData.links?.length || responseData.link_uuids?.length)) await this.resolveLinks(responseData, params, resolveId);\n\t\tif (this.resolveNestedRelations) for (const relUuid in this.relations[resolveId]) this.iterateTree(this.relations[resolveId][relUuid], relationParams, resolveId);\n\t\tif (responseData.story) this.iterateTree(responseData.story, relationParams, resolveId);\n\t\telse responseData.stories.forEach((story) => {\n\t\t\tthis.iterateTree(story, relationParams, resolveId);\n\t\t});\n\t\tthis.stringifiedStoriesCache = {};\n\t\tdelete this.links[resolveId];\n\t\tdelete this.relations[resolveId];\n\t}\n\tasync cacheResponse(url, params, retries, fetchOptions) {\n\t\tconst cacheKey = stringify({\n\t\t\turl,\n\t\t\tparams\n\t\t});\n\t\tconst provider = this.cacheProvider();\n\t\tif (params.version === \"published\" && url !== \"/cdn/spaces/me\") {\n\t\t\tconst cache = await provider.get(cacheKey);\n\t\t\tif (cache) return Promise.resolve(cache);\n\t\t}\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tconst res = await this.throttle(\"get\", url, params, fetchOptions);\n\t\t\t\tif (res.status !== 200) return reject(res);\n\t\t\t\tlet response = {\n\t\t\t\t\tdata: res.data,\n\t\t\t\t\theaders: res.headers\n\t\t\t\t};\n\t\t\t\tif (res.headers?.[\"per-page\"]) response = Object.assign({}, response, {\n\t\t\t\t\tperPage: res.headers[\"per-page\"] ? Number.parseInt(res.headers[\"per-page\"]) : 0,\n\t\t\t\t\ttotal: res.headers[\"per-page\"] ? Number.parseInt(res.headers.total) : 0\n\t\t\t\t});\n\t\t\t\tif (response.data.story || response.data.stories) {\n\t\t\t\t\tconst resolveId = this.resolveCounter = ++this.resolveCounter % 1e3;\n\t\t\t\t\tawait this.resolveStories(response.data, params, `${resolveId}`);\n\t\t\t\t\tresponse = await this.processInlineAssets(response);\n\t\t\t\t}\n\t\t\t\tif (params.version === \"published\" && url !== \"/cdn/spaces/me\") await provider.set(cacheKey, response);\n\t\t\t\tconst isCacheClearable = this.cache.clear === \"onpreview\" && params.version === \"draft\" || this.cache.clear === \"auto\";\n\t\t\t\tif (params.token && response.data.cv) {\n\t\t\t\t\tif (isCacheClearable && cacheVersions[params.token] && cacheVersions[params.token] !== response.data.cv) await this.flushCache();\n\t\t\t\t\tcacheVersions[params.token] = response.data.cv;\n\t\t\t\t}\n\t\t\t\treturn resolve(response);\n\t\t\t} catch (error) {\n\t\t\t\tif (error.response && error.status === 429) {\n\t\t\t\t\tretries = typeof retries === \"undefined\" ? 0 : retries + 1;\n\t\t\t\t\tif (retries < this.maxRetries) {\n\t\t\t\t\t\tconsole.log(`Hit rate limit. Retrying in ${this.retriesDelay / 1e3} seconds.`);\n\t\t\t\t\t\tawait delay(this.retriesDelay);\n\t\t\t\t\t\treturn this.cacheResponse(url, params, retries).then(resolve).catch(reject);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treject(error);\n\t\t\t}\n\t\t});\n\t}\n\tthrottledRequest(type, url, params, fetchOptions) {\n\t\tthis.client.setFetchOptions(fetchOptions);\n\t\treturn this.client[type](url, params);\n\t}\n\tcacheVersions() {\n\t\treturn cacheVersions;\n\t}\n\tcacheVersion() {\n\t\treturn cacheVersions[this.accessToken];\n\t}\n\tsetCacheVersion(cv) {\n\t\tif (this.accessToken) cacheVersions[this.accessToken] = cv;\n\t}\n\tclearCacheVersion() {\n\t\tif (this.accessToken) cacheVersions[this.accessToken] = 0;\n\t}\n\tcacheProvider() {\n\t\tswitch (this.cache.type) {\n\t\t\tcase \"memory\": return {\n\t\t\t\tget(key) {\n\t\t\t\t\treturn Promise.resolve(memory[key]);\n\t\t\t\t},\n\t\t\t\tgetAll() {\n\t\t\t\t\treturn Promise.resolve(memory);\n\t\t\t\t},\n\t\t\t\tset(key, content) {\n\t\t\t\t\tmemory[key] = content;\n\t\t\t\t\treturn Promise.resolve(void 0);\n\t\t\t\t},\n\t\t\t\tflush() {\n\t\t\t\t\tmemory = {};\n\t\t\t\t\treturn Promise.resolve(void 0);\n\t\t\t\t}\n\t\t\t};\n\t\t\tcase \"custom\": if (this.cache.custom) return this.cache.custom;\n\t\t\tdefault: return {\n\t\t\t\tget() {\n\t\t\t\t\treturn Promise.resolve();\n\t\t\t\t},\n\t\t\t\tgetAll() {\n\t\t\t\t\treturn Promise.resolve(void 0);\n\t\t\t\t},\n\t\t\t\tset() {\n\t\t\t\t\treturn Promise.resolve(void 0);\n\t\t\t\t},\n\t\t\t\tflush() {\n\t\t\t\t\treturn Promise.resolve(void 0);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\tasync flushCache() {\n\t\tawait this.cacheProvider().flush();\n\t\tthis.clearCacheVersion();\n\t\treturn this;\n\t}\n\tasync processInlineAssets(response) {\n\t\tif (!this.inlineAssets) return response;\n\t\tconst processNode = (node) => {\n\t\t\tif (!node || typeof node !== \"object\") return node;\n\t\t\tif (Array.isArray(node)) return node.map((item) => processNode(item));\n\t\t\tlet processedNode = { ...node };\n\t\t\tif (processedNode.fieldtype === \"asset\" && Array.isArray(response.data.assets)) processedNode = {\n\t\t\t\t...processedNode,\n\t\t\t\t...response.data.assets.find((asset) => asset.id === processedNode.id)\n\t\t\t};\n\t\t\tfor (const key in processedNode) if (typeof processedNode[key] === \"object\") processedNode[key] = processNode(processedNode[key]);\n\t\t\treturn processedNode;\n\t\t};\n\t\tif (response.data.story) response.data.story.content = processNode(response.data.story.content);\n\t\tif (response.data.stories) response.data.stories = response.data.stories.map((story) => {\n\t\t\tstory.content = processNode(story.content);\n\t\t\treturn story;\n\t\t});\n\t\treturn response;\n\t}\n};\nvar src_default = Storyblok;\n\n//#endregion\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3RvcnlibG9rLWpzLWNsaWVudC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFFBQVE7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0csTUFBTTtBQUN4RyxpQkFBaUIseUNBQXlDLE1BQU0sWUFBWSxHQUFHLDBCQUEwQjtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHlEQUF5RCxVQUFVO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQseUJBQXlCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDNkM7QUFDN0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXJ0aW4vcGVyc29uYWwtcHJvamVjdHMvc3RvcnlibG9rL3N0b3J5LXRyYXZlbC1hZ2VuY3kvbm9kZV9tb2R1bGVzL3N0b3J5Ymxvay1qcy1jbGllbnQvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyNyZWdpb24gc3JjL3Rocm90dGxlUHJvbWlzZS50c1xudmFyIEFib3J0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcblx0Y29uc3RydWN0b3IobXNnKSB7XG5cdFx0c3VwZXIobXNnKTtcblx0XHR0aGlzLm5hbWUgPSBcIkFib3J0RXJyb3JcIjtcblx0fVxufTtcbmZ1bmN0aW9uIHRocm90dGxlZFF1ZXVlKGZuLCBsaW1pdCwgaW50ZXJ2YWwpIHtcblx0aWYgKCFOdW1iZXIuaXNGaW5pdGUobGltaXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYGxpbWl0YCB0byBiZSBhIGZpbml0ZSBudW1iZXJcIik7XG5cdGlmICghTnVtYmVyLmlzRmluaXRlKGludGVydmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGBpbnRlcnZhbGAgdG8gYmUgYSBmaW5pdGUgbnVtYmVyXCIpO1xuXHRjb25zdCBxdWV1ZSA9IFtdO1xuXHRsZXQgdGltZW91dHMgPSBbXTtcblx0bGV0IGFjdGl2ZUNvdW50ID0gMDtcblx0bGV0IGlzQWJvcnRlZCA9IGZhbHNlO1xuXHRjb25zdCBuZXh0ID0gYXN5bmMgKCkgPT4ge1xuXHRcdGFjdGl2ZUNvdW50Kys7XG5cdFx0Y29uc3QgeCA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0aWYgKHgpIHRyeSB7XG5cdFx0XHRjb25zdCByZXMgPSBhd2FpdCBmbiguLi54LmFyZ3MpO1xuXHRcdFx0eC5yZXNvbHZlKHJlcyk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHgucmVqZWN0KGVycm9yKTtcblx0XHR9XG5cdFx0Y29uc3QgaWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdGFjdGl2ZUNvdW50LS07XG5cdFx0XHRpZiAocXVldWUubGVuZ3RoID4gMCkgbmV4dCgpO1xuXHRcdFx0dGltZW91dHMgPSB0aW1lb3V0cy5maWx0ZXIoKGN1cnJlbnRJZCkgPT4gY3VycmVudElkICE9PSBpZCk7XG5cdFx0fSwgaW50ZXJ2YWwpO1xuXHRcdGlmICghdGltZW91dHMuaW5jbHVkZXMoaWQpKSB0aW1lb3V0cy5wdXNoKGlkKTtcblx0fTtcblx0Y29uc3QgdGhyb3R0bGVkID0gKC4uLmFyZ3MpID0+IHtcblx0XHRpZiAoaXNBYm9ydGVkKSByZXR1cm4gUHJvbWlzZS5yZWplY3QoLyogQF9fUFVSRV9fICovIG5ldyBFcnJvcihcIlRocm90dGxlZCBmdW5jdGlvbiBpcyBhbHJlYWR5IGFib3J0ZWQgYW5kIG5vdCBhY2NlcHRpbmcgbmV3IHByb21pc2VzXCIpKTtcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdFx0cXVldWUucHVzaCh7XG5cdFx0XHRcdHJlc29sdmUsXG5cdFx0XHRcdHJlamVjdCxcblx0XHRcdFx0YXJnc1xuXHRcdFx0fSk7XG5cdFx0XHRpZiAoYWN0aXZlQ291bnQgPCBsaW1pdCkgbmV4dCgpO1xuXHRcdH0pO1xuXHR9O1xuXHR0aHJvdHRsZWQuYWJvcnQgPSAoKSA9PiB7XG5cdFx0aXNBYm9ydGVkID0gdHJ1ZTtcblx0XHR0aW1lb3V0cy5mb3JFYWNoKGNsZWFyVGltZW91dCk7XG5cdFx0dGltZW91dHMgPSBbXTtcblx0XHRxdWV1ZS5mb3JFYWNoKCh4KSA9PiB4LnJlamVjdCgoKSA9PiBuZXcgQWJvcnRFcnJvcihcIlRocm90dGxlIGZ1bmN0aW9uIGFib3J0ZWRcIikpKTtcblx0XHRxdWV1ZS5sZW5ndGggPSAwO1xuXHR9O1xuXHRyZXR1cm4gdGhyb3R0bGVkO1xufVxudmFyIHRocm90dGxlUHJvbWlzZV9kZWZhdWx0ID0gdGhyb3R0bGVkUXVldWU7XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91dGlscy50c1xuLyoqXG4qIENoZWNrcyBpZiBhIFVSTCBpcyBhIENETiBVUkxcbiogQHBhcmFtIHVybCAtIFRoZSBVUkwgdG8gY2hlY2tcbiogQHJldHVybnMgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBVUkwgaXMgYSBDRE4gVVJMXG4qL1xuY29uc3QgaXNDRE5VcmwgPSAodXJsID0gXCJcIikgPT4gdXJsLmluY2x1ZGVzKFwiL2Nkbi9cIik7XG4vKipcbiogR2V0cyBwYWdpbmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBBUEkgcmVxdWVzdFxuKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBiYXNlIG9wdGlvbnNcbiogQHBhcmFtIHBlclBhZ2UgLSBOdW1iZXIgb2YgaXRlbXMgcGVyIHBhZ2VcbiogQHBhcmFtIHBhZ2UgLSBDdXJyZW50IHBhZ2UgbnVtYmVyXG4qIEByZXR1cm5zIE9iamVjdCB3aXRoIHBhZ2luYXRpb24gb3B0aW9uc1xuKi9cbmNvbnN0IGdldE9wdGlvbnNQYWdlID0gKG9wdGlvbnMsIHBlclBhZ2UgPSAyNSwgcGFnZSA9IDEpID0+ICh7XG5cdC4uLm9wdGlvbnMsXG5cdHBlcl9wYWdlOiBwZXJQYWdlLFxuXHRwYWdlXG59KTtcbi8qKlxuKiBDcmVhdGVzIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIGFmdGVyIHRoZSBzcGVjaWZpZWQgbWlsbGlzZWNvbmRzXG4qIEBwYXJhbSBtcyAtIE1pbGxpc2Vjb25kcyB0byBkZWxheVxuKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgYWZ0ZXIgdGhlIGRlbGF5XG4qL1xuY29uc3QgZGVsYXkgPSAobXMpID0+IG5ldyBQcm9taXNlKChyZXMpID0+IHNldFRpbWVvdXQocmVzLCBtcykpO1xuLyoqXG4qIENyZWF0ZXMgYW4gYXJyYXkgb2Ygc3BlY2lmaWVkIGxlbmd0aCB1c2luZyBhIG1hcHBpbmcgZnVuY3Rpb25cbiogQHBhcmFtIGxlbmd0aCAtIExlbmd0aCBvZiB0aGUgYXJyYXlcbiogQHBhcmFtIGZ1bmMgLSBNYXBwaW5nIGZ1bmN0aW9uXG4qIEByZXR1cm5zIEFycmF5IG9mIHNwZWNpZmllZCBsZW5ndGhcbiovXG5jb25zdCBhcnJheUZyb20gPSAobGVuZ3RoID0gMCwgZnVuYykgPT4gQXJyYXkuZnJvbSh7IGxlbmd0aCB9LCBmdW5jKTtcbi8qKlxuKiBDcmVhdGVzIGFuIGFycmF5IG9mIG51bWJlcnMgaW4gdGhlIHNwZWNpZmllZCByYW5nZVxuKiBAcGFyYW0gc3RhcnQgLSBTdGFydCBvZiB0aGUgcmFuZ2VcbiogQHBhcmFtIGVuZCAtIEVuZCBvZiB0aGUgcmFuZ2VcbiogQHJldHVybnMgQXJyYXkgb2YgbnVtYmVycyBpbiB0aGUgcmFuZ2VcbiovXG5jb25zdCByYW5nZSA9IChzdGFydCA9IDAsIGVuZCA9IHN0YXJ0KSA9PiB7XG5cdGNvbnN0IGxlbmd0aCA9IE1hdGguYWJzKGVuZCAtIHN0YXJ0KSB8fCAwO1xuXHRjb25zdCBzdGVwID0gc3RhcnQgPCBlbmQgPyAxIDogLTE7XG5cdHJldHVybiBhcnJheUZyb20obGVuZ3RoLCAoXywgaSkgPT4gaSAqIHN0ZXAgKyBzdGFydCk7XG59O1xuLyoqXG4qIE1hcHMgYW4gYXJyYXkgYXN5bmNocm9ub3VzbHlcbiogQHBhcmFtIGFyciAtIEFycmF5IHRvIG1hcFxuKiBAcGFyYW0gZnVuYyAtIEFzeW5jIG1hcHBpbmcgZnVuY3Rpb25cbiogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gbWFwcGVkIGFycmF5XG4qL1xuY29uc3QgYXN5bmNNYXAgPSBhc3luYyAoYXJyLCBmdW5jKSA9PiBQcm9taXNlLmFsbChhcnIubWFwKGZ1bmMpKTtcbi8qKlxuKiBGbGF0dGVucyBhbiBhcnJheSB1c2luZyBhIG1hcHBpbmcgZnVuY3Rpb25cbiogQHBhcmFtIGFyciAtIEFycmF5IHRvIGZsYXR0ZW5cbiogQHBhcmFtIGZ1bmMgLSBNYXBwaW5nIGZ1bmN0aW9uXG4qIEByZXR1cm5zIEZsYXR0ZW5lZCBhcnJheVxuKi9cbmNvbnN0IGZsYXRNYXAgPSAoYXJyID0gW10sIGZ1bmMpID0+IGFyci5tYXAoZnVuYykucmVkdWNlKCh4cywgeXMpID0+IFsuLi54cywgLi4ueXNdLCBbXSk7XG4vKipcbiogU3RyaW5naWZpZXMgYW4gb2JqZWN0IGludG8gYSBVUkwgcXVlcnkgc3RyaW5nXG4qIEBwYXJhbSBwYXJhbXMgLSBQYXJhbWV0ZXJzIHRvIHN0cmluZ2lmeVxuKiBAcGFyYW0gcHJlZml4IC0gUHJlZml4IGZvciBuZXN0ZWQga2V5c1xuKiBAcGFyYW0gaXNBcnJheSAtIFdoZXRoZXIgdGhlIGN1cnJlbnQgbGV2ZWwgaXMgYW4gYXJyYXlcbiogQHJldHVybnMgU3RyaW5naWZpZWQgcXVlcnkgcGFyYW1ldGVyc1xuKi9cbmNvbnN0IHN0cmluZ2lmeSA9IChwYXJhbXMsIHByZWZpeCwgaXNBcnJheSkgPT4ge1xuXHRjb25zdCBwYWlycyA9IFtdO1xuXHRmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcblx0XHRpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbXMsIGtleSkpIGNvbnRpbnVlO1xuXHRcdGNvbnN0IHZhbHVlID0gcGFyYW1zW2tleV07XG5cdFx0aWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDApIGNvbnRpbnVlO1xuXHRcdGNvbnN0IGVua2V5ID0gaXNBcnJheSA/IFwiXCIgOiBlbmNvZGVVUklDb21wb25lbnQoa2V5KTtcblx0XHRsZXQgcGFpcjtcblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSBwYWlyID0gc3RyaW5naWZ5KHZhbHVlLCBwcmVmaXggPyBwcmVmaXggKyBlbmNvZGVVUklDb21wb25lbnQoYFske2Vua2V5fV1gKSA6IGVua2V5LCBBcnJheS5pc0FycmF5KHZhbHVlKSk7XG5cdFx0ZWxzZSBwYWlyID0gYCR7cHJlZml4ID8gcHJlZml4ICsgZW5jb2RlVVJJQ29tcG9uZW50KGBbJHtlbmtleX1dYCkgOiBlbmtleX09JHtlbmNvZGVVUklDb21wb25lbnQodmFsdWUpfWA7XG5cdFx0cGFpcnMucHVzaChwYWlyKTtcblx0fVxuXHRyZXR1cm4gcGFpcnMuam9pbihcIiZcIik7XG59O1xuLyoqXG4qIEdldHMgdGhlIGJhc2UgVVJMIGZvciBhIHNwZWNpZmljIHJlZ2lvblxuKiBAcGFyYW0gcmVnaW9uQ29kZSAtIFJlZ2lvbiBjb2RlIChldSwgdXMsIGNuLCBhcCwgY2EpXG4qIEByZXR1cm5zIEJhc2UgVVJMIGZvciB0aGUgcmVnaW9uXG4qL1xuY29uc3QgZ2V0UmVnaW9uVVJMID0gKHJlZ2lvbkNvZGUpID0+IHtcblx0Y29uc3QgUkVHSU9OX1VSTFMgPSB7XG5cdFx0ZXU6IFwiYXBpLnN0b3J5Ymxvay5jb21cIixcblx0XHR1czogXCJhcGktdXMuc3RvcnlibG9rLmNvbVwiLFxuXHRcdGNuOiBcImFwcC5zdG9yeWJsb2tjaGluYS5jblwiLFxuXHRcdGFwOiBcImFwaS1hcC5zdG9yeWJsb2suY29tXCIsXG5cdFx0Y2E6IFwiYXBpLWNhLnN0b3J5Ymxvay5jb21cIlxuXHR9O1xuXHRyZXR1cm4gUkVHSU9OX1VSTFNbcmVnaW9uQ29kZV0gPz8gUkVHSU9OX1VSTFMuZXU7XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvc2JGZXRjaC50c1xudmFyIFNiRmV0Y2ggPSBjbGFzcyB7XG5cdGJhc2VVUkw7XG5cdHRpbWVvdXQ7XG5cdGhlYWRlcnM7XG5cdHJlc3BvbnNlSW50ZXJjZXB0b3I7XG5cdGZldGNoO1xuXHRlamVjdEludGVyY2VwdG9yO1xuXHR1cmw7XG5cdHBhcmFtZXRlcnM7XG5cdGZldGNoT3B0aW9ucztcblx0Y29uc3RydWN0b3IoJGMpIHtcblx0XHR0aGlzLmJhc2VVUkwgPSAkYy5iYXNlVVJMO1xuXHRcdHRoaXMuaGVhZGVycyA9ICRjLmhlYWRlcnMgfHwgbmV3IEhlYWRlcnMoKTtcblx0XHR0aGlzLnRpbWVvdXQgPSAkYz8udGltZW91dCA/ICRjLnRpbWVvdXQgKiAxZTMgOiAwO1xuXHRcdHRoaXMucmVzcG9uc2VJbnRlcmNlcHRvciA9ICRjLnJlc3BvbnNlSW50ZXJjZXB0b3I7XG5cdFx0dGhpcy5mZXRjaCA9ICguLi5hcmdzKSA9PiAkYy5mZXRjaCA/ICRjLmZldGNoKC4uLmFyZ3MpIDogZmV0Y2goLi4uYXJncyk7XG5cdFx0dGhpcy5lamVjdEludGVyY2VwdG9yID0gZmFsc2U7XG5cdFx0dGhpcy51cmwgPSBcIlwiO1xuXHRcdHRoaXMucGFyYW1ldGVycyA9IHt9O1xuXHRcdHRoaXMuZmV0Y2hPcHRpb25zID0ge307XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAcGFyYW0gdXJsIHN0cmluZ1xuXHQqIEBwYXJhbSBwYXJhbXMgSVNiU3Rvcmllc1BhcmFtc1xuXHQqIEByZXR1cm5zIFByb21pc2U8SVNiUmVzcG9uc2UgfCBFcnJvcj5cblx0Ki9cblx0Z2V0KHVybCwgcGFyYW1zKSB7XG5cdFx0dGhpcy51cmwgPSB1cmw7XG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0gcGFyYW1zO1xuXHRcdHJldHVybiB0aGlzLl9tZXRob2RIYW5kbGVyKFwiZ2V0XCIpO1xuXHR9XG5cdHBvc3QodXJsLCBwYXJhbXMpIHtcblx0XHR0aGlzLnVybCA9IHVybDtcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBwYXJhbXM7XG5cdFx0cmV0dXJuIHRoaXMuX21ldGhvZEhhbmRsZXIoXCJwb3N0XCIpO1xuXHR9XG5cdHB1dCh1cmwsIHBhcmFtcykge1xuXHRcdHRoaXMudXJsID0gdXJsO1xuXHRcdHRoaXMucGFyYW1ldGVycyA9IHBhcmFtcztcblx0XHRyZXR1cm4gdGhpcy5fbWV0aG9kSGFuZGxlcihcInB1dFwiKTtcblx0fVxuXHRkZWxldGUodXJsLCBwYXJhbXMpIHtcblx0XHR0aGlzLnVybCA9IHVybDtcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBwYXJhbXMgPz8ge307XG5cdFx0cmV0dXJuIHRoaXMuX21ldGhvZEhhbmRsZXIoXCJkZWxldGVcIik7XG5cdH1cblx0YXN5bmMgX3Jlc3BvbnNlSGFuZGxlcihyZXMpIHtcblx0XHRjb25zdCBoZWFkZXJzID0gW107XG5cdFx0Y29uc3QgcmVzcG9uc2UgPSB7XG5cdFx0XHRkYXRhOiB7fSxcblx0XHRcdGhlYWRlcnM6IHt9LFxuXHRcdFx0c3RhdHVzOiAwLFxuXHRcdFx0c3RhdHVzVGV4dDogXCJcIlxuXHRcdH07XG5cdFx0aWYgKHJlcy5zdGF0dXMgIT09IDIwNCkgYXdhaXQgcmVzLmpzb24oKS50aGVuKCgkcikgPT4ge1xuXHRcdFx0cmVzcG9uc2UuZGF0YSA9ICRyO1xuXHRcdH0pO1xuXHRcdGZvciAoY29uc3QgcGFpciBvZiByZXMuaGVhZGVycy5lbnRyaWVzKCkpIGhlYWRlcnNbcGFpclswXV0gPSBwYWlyWzFdO1xuXHRcdHJlc3BvbnNlLmhlYWRlcnMgPSB7IC4uLmhlYWRlcnMgfTtcblx0XHRyZXNwb25zZS5zdGF0dXMgPSByZXMuc3RhdHVzO1xuXHRcdHJlc3BvbnNlLnN0YXR1c1RleHQgPSByZXMuc3RhdHVzVGV4dDtcblx0XHRyZXR1cm4gcmVzcG9uc2U7XG5cdH1cblx0YXN5bmMgX21ldGhvZEhhbmRsZXIobWV0aG9kKSB7XG5cdFx0bGV0IHVybFN0cmluZyA9IGAke3RoaXMuYmFzZVVSTH0ke3RoaXMudXJsfWA7XG5cdFx0bGV0IGJvZHkgPSBudWxsO1xuXHRcdGlmIChtZXRob2QgPT09IFwiZ2V0XCIpIHVybFN0cmluZyA9IGAke3RoaXMuYmFzZVVSTH0ke3RoaXMudXJsfT8ke3N0cmluZ2lmeSh0aGlzLnBhcmFtZXRlcnMpfWA7XG5cdFx0ZWxzZSBib2R5ID0gSlNPTi5zdHJpbmdpZnkodGhpcy5wYXJhbWV0ZXJzKTtcblx0XHRjb25zdCB1cmwgPSBuZXcgVVJMKHVybFN0cmluZyk7XG5cdFx0Y29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcblx0XHRjb25zdCB7IHNpZ25hbCB9ID0gY29udHJvbGxlcjtcblx0XHRsZXQgdGltZW91dDtcblx0XHRpZiAodGhpcy50aW1lb3V0KSB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIHRoaXMudGltZW91dCk7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IGZldGNoUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoKGAke3VybH1gLCB7XG5cdFx0XHRcdG1ldGhvZCxcblx0XHRcdFx0aGVhZGVyczogdGhpcy5oZWFkZXJzLFxuXHRcdFx0XHRib2R5LFxuXHRcdFx0XHRzaWduYWwsXG5cdFx0XHRcdC4uLnRoaXMuZmV0Y2hPcHRpb25zXG5cdFx0XHR9KTtcblx0XHRcdGlmICh0aGlzLnRpbWVvdXQpIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0XHRcdGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fcmVzcG9uc2VIYW5kbGVyKGZldGNoUmVzcG9uc2UpO1xuXHRcdFx0aWYgKHRoaXMucmVzcG9uc2VJbnRlcmNlcHRvciAmJiAhdGhpcy5lamVjdEludGVyY2VwdG9yKSByZXR1cm4gdGhpcy5fc3RhdHVzSGFuZGxlcih0aGlzLnJlc3BvbnNlSW50ZXJjZXB0b3IocmVzcG9uc2UpKTtcblx0XHRcdGVsc2UgcmV0dXJuIHRoaXMuX3N0YXR1c0hhbmRsZXIocmVzcG9uc2UpO1xuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0Y29uc3QgZXJyb3IgPSB7IG1lc3NhZ2U6IGVyciB9O1xuXHRcdFx0cmV0dXJuIGVycm9yO1xuXHRcdH1cblx0fVxuXHRzZXRGZXRjaE9wdGlvbnMoZmV0Y2hPcHRpb25zID0ge30pIHtcblx0XHRpZiAoT2JqZWN0LmtleXMoZmV0Y2hPcHRpb25zKS5sZW5ndGggPiAwICYmIFwibWV0aG9kXCIgaW4gZmV0Y2hPcHRpb25zKSBkZWxldGUgZmV0Y2hPcHRpb25zLm1ldGhvZDtcblx0XHR0aGlzLmZldGNoT3B0aW9ucyA9IHsgLi4uZmV0Y2hPcHRpb25zIH07XG5cdH1cblx0ZWplY3QoKSB7XG5cdFx0dGhpcy5lamVjdEludGVyY2VwdG9yID0gdHJ1ZTtcblx0fVxuXHQvKipcblx0KiBOb3JtYWxpemVzIGVycm9yIG1lc3NhZ2VzIGZyb20gZGlmZmVyZW50IHJlc3BvbnNlIHN0cnVjdHVyZXNcblx0KiBAcGFyYW0gZGF0YSBUaGUgcmVzcG9uc2UgZGF0YSB0aGF0IG1pZ2h0IGNvbnRhaW4gZXJyb3IgaW5mb3JtYXRpb25cblx0KiBAcmV0dXJucyBBIG5vcm1hbGl6ZWQgZXJyb3IgbWVzc2FnZSBzdHJpbmdcblx0Ki9cblx0X25vcm1hbGl6ZUVycm9yTWVzc2FnZShkYXRhKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHJldHVybiBkYXRhWzBdIHx8IFwiVW5rbm93biBlcnJvclwiO1xuXHRcdGlmIChkYXRhICYmIHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRpZiAoZGF0YS5lcnJvcikgcmV0dXJuIGRhdGEuZXJyb3I7XG5cdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG5cdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KGRhdGFba2V5XSkpIHJldHVybiBgJHtrZXl9OiAke2RhdGFba2V5XVswXX1gO1xuXHRcdFx0XHRpZiAodHlwZW9mIGRhdGFba2V5XSA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGAke2tleX06ICR7ZGF0YVtrZXldfWA7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZGF0YS5zbHVnKSByZXR1cm4gZGF0YS5zbHVnO1xuXHRcdH1cblx0XHRyZXR1cm4gXCJVbmtub3duIGVycm9yXCI7XG5cdH1cblx0X3N0YXR1c0hhbmRsZXIocmVzKSB7XG5cdFx0Y29uc3Qgc3RhdHVzT2sgPSAvMjBbMC02XS9nO1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0XHRpZiAoc3RhdHVzT2sudGVzdChgJHtyZXMuc3RhdHVzfWApKSByZXR1cm4gcmVzb2x2ZShyZXMpO1xuXHRcdFx0Y29uc3QgZXJyb3IgPSB7XG5cdFx0XHRcdG1lc3NhZ2U6IHRoaXMuX25vcm1hbGl6ZUVycm9yTWVzc2FnZShyZXMuZGF0YSksXG5cdFx0XHRcdHN0YXR1czogcmVzLnN0YXR1cyxcblx0XHRcdFx0cmVzcG9uc2U6IHJlc1xuXHRcdFx0fTtcblx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0fSk7XG5cdH1cbn07XG52YXIgc2JGZXRjaF9kZWZhdWx0ID0gU2JGZXRjaDtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2NvbnN0YW50cy50c1xuY29uc3QgU1RPUllCTE9LX0FHRU5UID0gXCJTQi1BZ2VudFwiO1xuY29uc3QgU1RPUllCTE9LX0pTX0NMSUVOVF9BR0VOVCA9IHtcblx0ZGVmYXVsdEFnZW50TmFtZTogXCJTQi1KUy1DTElFTlRcIixcblx0ZGVmYXVsdEFnZW50VmVyc2lvbjogXCJTQi1BZ2VudC1WZXJzaW9uXCIsXG5cdHBhY2thZ2VWZXJzaW9uOiBcIjcuMC4wXCJcbn07XG5jb25zdCBTdG9yeWJsb2tDb250ZW50VmVyc2lvbiA9IHtcblx0RFJBRlQ6IFwiZHJhZnRcIixcblx0UFVCTElTSEVEOiBcInB1Ymxpc2hlZFwiXG59O1xuY29uc3QgU3RvcnlibG9rQ29udGVudFZlcnNpb25WYWx1ZXMgPSBPYmplY3QudmFsdWVzKFN0b3J5Ymxva0NvbnRlbnRWZXJzaW9uKTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2luZGV4LnRzXG5sZXQgbWVtb3J5ID0ge307XG5jb25zdCBjYWNoZVZlcnNpb25zID0ge307XG52YXIgU3RvcnlibG9rID0gY2xhc3Mge1xuXHRjbGllbnQ7XG5cdG1heFJldHJpZXM7XG5cdHJldHJpZXNEZWxheTtcblx0dGhyb3R0bGU7XG5cdGFjY2Vzc1Rva2VuO1xuXHRjYWNoZTtcblx0cmVzb2x2ZUNvdW50ZXI7XG5cdHJlbGF0aW9ucztcblx0bGlua3M7XG5cdHZlcnNpb247XG5cdC8qKlxuXHQqIEBkZXByZWNhdGVkIFRoaXMgcHJvcGVydHkgaXMgZGVwcmVjYXRlZC4gVXNlIHRoZSBzdGFuZGFsb25lIGByaWNoVGV4dFJlc29sdmVyYCBmcm9tIGBAc3RvcnlibG9rL3JpY2h0ZXh0YCBpbnN0ZWFkLlxuXHQqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N0b3J5Ymxvay9yaWNodGV4dFxuXHQqL1xuXHRyaWNoVGV4dFJlc29sdmVyO1xuXHRyZXNvbHZlTmVzdGVkUmVsYXRpb25zO1xuXHRzdHJpbmdpZmllZFN0b3JpZXNDYWNoZTtcblx0aW5saW5lQXNzZXRzO1xuXHQvKipcblx0KlxuXHQqIEBwYXJhbSBjb25maWcgSVNiQ29uZmlnIGludGVyZmFjZVxuXHQqIEBwYXJhbSBwRW5kcG9pbnQgc3RyaW5nLCBvcHRpb25hbFxuXHQqL1xuXHRjb25zdHJ1Y3Rvcihjb25maWcsIHBFbmRwb2ludCkge1xuXHRcdGxldCBlbmRwb2ludCA9IGNvbmZpZy5lbmRwb2ludCB8fCBwRW5kcG9pbnQ7XG5cdFx0aWYgKCFlbmRwb2ludCkge1xuXHRcdFx0Y29uc3QgcHJvdG9jb2wgPSBjb25maWcuaHR0cHMgPT09IGZhbHNlID8gXCJodHRwXCIgOiBcImh0dHBzXCI7XG5cdFx0XHRpZiAoIWNvbmZpZy5vYXV0aFRva2VuKSBlbmRwb2ludCA9IGAke3Byb3RvY29sfTovLyR7Z2V0UmVnaW9uVVJMKGNvbmZpZy5yZWdpb24pfS92MmA7XG5cdFx0XHRlbHNlIGVuZHBvaW50ID0gYCR7cHJvdG9jb2x9Oi8vJHtnZXRSZWdpb25VUkwoY29uZmlnLnJlZ2lvbil9L3YxYDtcblx0XHR9XG5cdFx0Y29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG5cdFx0aGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuXHRcdGhlYWRlcnMuc2V0KFwiQWNjZXB0XCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcblx0XHRpZiAoY29uZmlnLmhlYWRlcnMpIHtcblx0XHRcdGNvbnN0IGVudHJpZXMgPSBjb25maWcuaGVhZGVycy5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIkhlYWRlcnNcIiA/IGNvbmZpZy5oZWFkZXJzLmVudHJpZXMoKS50b0FycmF5KCkgOiBPYmplY3QuZW50cmllcyhjb25maWcuaGVhZGVycyk7XG5cdFx0XHRlbnRyaWVzLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuXHRcdFx0XHRoZWFkZXJzLnNldChrZXksIHZhbHVlKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRpZiAoIWhlYWRlcnMuaGFzKFNUT1JZQkxPS19BR0VOVCkpIHtcblx0XHRcdGhlYWRlcnMuc2V0KFNUT1JZQkxPS19BR0VOVCwgU1RPUllCTE9LX0pTX0NMSUVOVF9BR0VOVC5kZWZhdWx0QWdlbnROYW1lKTtcblx0XHRcdGhlYWRlcnMuc2V0KFNUT1JZQkxPS19KU19DTElFTlRfQUdFTlQuZGVmYXVsdEFnZW50VmVyc2lvbiwgU1RPUllCTE9LX0pTX0NMSUVOVF9BR0VOVC5wYWNrYWdlVmVyc2lvbik7XG5cdFx0fVxuXHRcdGxldCByYXRlTGltaXQgPSA1O1xuXHRcdGlmIChjb25maWcub2F1dGhUb2tlbikge1xuXHRcdFx0aGVhZGVycy5zZXQoXCJBdXRob3JpemF0aW9uXCIsIGNvbmZpZy5vYXV0aFRva2VuKTtcblx0XHRcdHJhdGVMaW1pdCA9IDM7XG5cdFx0fVxuXHRcdGlmIChjb25maWcucmF0ZUxpbWl0KSByYXRlTGltaXQgPSBjb25maWcucmF0ZUxpbWl0O1xuXHRcdHRoaXMubWF4UmV0cmllcyA9IGNvbmZpZy5tYXhSZXRyaWVzIHx8IDEwO1xuXHRcdHRoaXMucmV0cmllc0RlbGF5ID0gMzAwO1xuXHRcdHRoaXMudGhyb3R0bGUgPSB0aHJvdHRsZVByb21pc2VfZGVmYXVsdCh0aGlzLnRocm90dGxlZFJlcXVlc3QuYmluZCh0aGlzKSwgcmF0ZUxpbWl0LCAxZTMpO1xuXHRcdHRoaXMuYWNjZXNzVG9rZW4gPSBjb25maWcuYWNjZXNzVG9rZW4gfHwgXCJcIjtcblx0XHR0aGlzLnJlbGF0aW9ucyA9IHt9O1xuXHRcdHRoaXMubGlua3MgPSB7fTtcblx0XHR0aGlzLmNhY2hlID0gY29uZmlnLmNhY2hlIHx8IHsgY2xlYXI6IFwibWFudWFsXCIgfTtcblx0XHR0aGlzLnJlc29sdmVDb3VudGVyID0gMDtcblx0XHR0aGlzLnJlc29sdmVOZXN0ZWRSZWxhdGlvbnMgPSBjb25maWcucmVzb2x2ZU5lc3RlZFJlbGF0aW9ucyB8fCB0cnVlO1xuXHRcdHRoaXMuc3RyaW5naWZpZWRTdG9yaWVzQ2FjaGUgPSB7fTtcblx0XHR0aGlzLnZlcnNpb24gPSBjb25maWcudmVyc2lvbiB8fCBTdG9yeWJsb2tDb250ZW50VmVyc2lvbi5QVUJMSVNIRUQ7XG5cdFx0dGhpcy5pbmxpbmVBc3NldHMgPSBjb25maWcuaW5saW5lQXNzZXRzIHx8IGZhbHNlO1xuXHRcdHRoaXMuY2xpZW50ID0gbmV3IHNiRmV0Y2hfZGVmYXVsdCh7XG5cdFx0XHRiYXNlVVJMOiBlbmRwb2ludCxcblx0XHRcdHRpbWVvdXQ6IGNvbmZpZy50aW1lb3V0IHx8IDAsXG5cdFx0XHRoZWFkZXJzLFxuXHRcdFx0cmVzcG9uc2VJbnRlcmNlcHRvcjogY29uZmlnLnJlc3BvbnNlSW50ZXJjZXB0b3IsXG5cdFx0XHRmZXRjaDogY29uZmlnLmZldGNoXG5cdFx0fSk7XG5cdH1cblx0cGFyc2VQYXJhbXMocGFyYW1zKSB7XG5cdFx0aWYgKCFwYXJhbXMudG9rZW4pIHBhcmFtcy50b2tlbiA9IHRoaXMuZ2V0VG9rZW4oKTtcblx0XHRpZiAoIXBhcmFtcy5jdikgcGFyYW1zLmN2ID0gY2FjaGVWZXJzaW9uc1twYXJhbXMudG9rZW5dO1xuXHRcdGlmIChBcnJheS5pc0FycmF5KHBhcmFtcy5yZXNvbHZlX3JlbGF0aW9ucykpIHBhcmFtcy5yZXNvbHZlX3JlbGF0aW9ucyA9IHBhcmFtcy5yZXNvbHZlX3JlbGF0aW9ucy5qb2luKFwiLFwiKTtcblx0XHRpZiAodHlwZW9mIHBhcmFtcy5yZXNvbHZlX3JlbGF0aW9ucyAhPT0gXCJ1bmRlZmluZWRcIikgcGFyYW1zLnJlc29sdmVfbGV2ZWwgPSAyO1xuXHRcdHJldHVybiBwYXJhbXM7XG5cdH1cblx0ZmFjdG9yeVBhcmFtT3B0aW9ucyh1cmwsIHBhcmFtcykge1xuXHRcdGlmIChpc0NETlVybCh1cmwpKSByZXR1cm4gdGhpcy5wYXJzZVBhcmFtcyhwYXJhbXMpO1xuXHRcdHJldHVybiBwYXJhbXM7XG5cdH1cblx0bWFrZVJlcXVlc3QodXJsLCBwYXJhbXMsIHBlcl9wYWdlLCBwYWdlLCBmZXRjaE9wdGlvbnMpIHtcblx0XHRjb25zdCBxdWVyeSA9IHRoaXMuZmFjdG9yeVBhcmFtT3B0aW9ucyh1cmwsIGdldE9wdGlvbnNQYWdlKHBhcmFtcywgcGVyX3BhZ2UsIHBhZ2UpKTtcblx0XHRyZXR1cm4gdGhpcy5jYWNoZVJlc3BvbnNlKHVybCwgcXVlcnksIHZvaWQgMCwgZmV0Y2hPcHRpb25zKTtcblx0fVxuXHRnZXQoc2x1ZywgcGFyYW1zID0ge30sIGZldGNoT3B0aW9ucykge1xuXHRcdGlmICghcGFyYW1zKSBwYXJhbXMgPSB7fTtcblx0XHRjb25zdCB1cmwgPSBgLyR7c2x1Z31gO1xuXHRcdGlmIChpc0NETlVybCh1cmwpKSBwYXJhbXMudmVyc2lvbiA9IHBhcmFtcy52ZXJzaW9uIHx8IHRoaXMudmVyc2lvbjtcblx0XHRjb25zdCBxdWVyeSA9IHRoaXMuZmFjdG9yeVBhcmFtT3B0aW9ucyh1cmwsIHBhcmFtcyk7XG5cdFx0cmV0dXJuIHRoaXMuY2FjaGVSZXNwb25zZSh1cmwsIHF1ZXJ5LCB2b2lkIDAsIGZldGNoT3B0aW9ucyk7XG5cdH1cblx0YXN5bmMgZ2V0QWxsKHNsdWcsIHBhcmFtcyA9IHt9LCBlbnRpdHksIGZldGNoT3B0aW9ucykge1xuXHRcdGNvbnN0IHBlclBhZ2UgPSBwYXJhbXM/LnBlcl9wYWdlIHx8IDI1O1xuXHRcdGNvbnN0IHVybCA9IGAvJHtzbHVnfWAucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuXHRcdGNvbnN0IGUgPSBlbnRpdHkgPz8gdXJsLnN1YnN0cmluZyh1cmwubGFzdEluZGV4T2YoXCIvXCIpICsgMSk7XG5cdFx0cGFyYW1zLnZlcnNpb24gPSBwYXJhbXMudmVyc2lvbiB8fCB0aGlzLnZlcnNpb247XG5cdFx0Y29uc3QgZmlyc3RQYWdlID0gMTtcblx0XHRjb25zdCBmaXJzdFJlcyA9IGF3YWl0IHRoaXMubWFrZVJlcXVlc3QodXJsLCBwYXJhbXMsIHBlclBhZ2UsIGZpcnN0UGFnZSwgZmV0Y2hPcHRpb25zKTtcblx0XHRjb25zdCBsYXN0UGFnZSA9IGZpcnN0UmVzLnRvdGFsID8gTWF0aC5jZWlsKGZpcnN0UmVzLnRvdGFsIC8gKGZpcnN0UmVzLnBlclBhZ2UgfHwgcGVyUGFnZSkpIDogMTtcblx0XHRjb25zdCByZXN0UmVzID0gYXdhaXQgYXN5bmNNYXAocmFuZ2UoZmlyc3RQYWdlLCBsYXN0UGFnZSksIChpKSA9PiB7XG5cdFx0XHRyZXR1cm4gdGhpcy5tYWtlUmVxdWVzdCh1cmwsIHBhcmFtcywgcGVyUGFnZSwgaSArIDEsIGZldGNoT3B0aW9ucyk7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIGZsYXRNYXAoW2ZpcnN0UmVzLCAuLi5yZXN0UmVzXSwgKHJlcykgPT4gT2JqZWN0LnZhbHVlcyhyZXMuZGF0YVtlXSkpO1xuXHR9XG5cdHBvc3Qoc2x1ZywgcGFyYW1zID0ge30sIGZldGNoT3B0aW9ucykge1xuXHRcdGNvbnN0IHVybCA9IGAvJHtzbHVnfWA7XG5cdFx0cmV0dXJuIHRoaXMudGhyb3R0bGUoXCJwb3N0XCIsIHVybCwgcGFyYW1zLCBmZXRjaE9wdGlvbnMpO1xuXHR9XG5cdHB1dChzbHVnLCBwYXJhbXMgPSB7fSwgZmV0Y2hPcHRpb25zKSB7XG5cdFx0Y29uc3QgdXJsID0gYC8ke3NsdWd9YDtcblx0XHRyZXR1cm4gdGhpcy50aHJvdHRsZShcInB1dFwiLCB1cmwsIHBhcmFtcywgZmV0Y2hPcHRpb25zKTtcblx0fVxuXHRkZWxldGUoc2x1ZywgcGFyYW1zID0ge30sIGZldGNoT3B0aW9ucykge1xuXHRcdGlmICghcGFyYW1zKSBwYXJhbXMgPSB7fTtcblx0XHRjb25zdCB1cmwgPSBgLyR7c2x1Z31gO1xuXHRcdHJldHVybiB0aGlzLnRocm90dGxlKFwiZGVsZXRlXCIsIHVybCwgcGFyYW1zLCBmZXRjaE9wdGlvbnMpO1xuXHR9XG5cdGdldFN0b3JpZXMocGFyYW1zID0ge30sIGZldGNoT3B0aW9ucykge1xuXHRcdHRoaXMuX2FkZFJlc29sdmVMZXZlbChwYXJhbXMpO1xuXHRcdHJldHVybiB0aGlzLmdldChcImNkbi9zdG9yaWVzXCIsIHBhcmFtcywgZmV0Y2hPcHRpb25zKTtcblx0fVxuXHRnZXRTdG9yeShzbHVnLCBwYXJhbXMgPSB7fSwgZmV0Y2hPcHRpb25zKSB7XG5cdFx0dGhpcy5fYWRkUmVzb2x2ZUxldmVsKHBhcmFtcyk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0KGBjZG4vc3Rvcmllcy8ke3NsdWd9YCwgcGFyYW1zLCBmZXRjaE9wdGlvbnMpO1xuXHR9XG5cdGdldFRva2VuKCkge1xuXHRcdHJldHVybiB0aGlzLmFjY2Vzc1Rva2VuO1xuXHR9XG5cdGVqZWN0SW50ZXJjZXB0b3IoKSB7XG5cdFx0dGhpcy5jbGllbnQuZWplY3QoKTtcblx0fVxuXHRfYWRkUmVzb2x2ZUxldmVsKHBhcmFtcykge1xuXHRcdGlmICh0eXBlb2YgcGFyYW1zLnJlc29sdmVfcmVsYXRpb25zICE9PSBcInVuZGVmaW5lZFwiKSBwYXJhbXMucmVzb2x2ZV9sZXZlbCA9IDI7XG5cdH1cblx0X2NsZWFuQ29weSh2YWx1ZSkge1xuXHRcdHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG5cdH1cblx0X2luc2VydExpbmtzKGp0cmVlLCB0cmVlSXRlbSwgcmVzb2x2ZUlkKSB7XG5cdFx0Y29uc3Qgbm9kZSA9IGp0cmVlW3RyZWVJdGVtXTtcblx0XHRpZiAobm9kZSAmJiBub2RlLmZpZWxkdHlwZSA9PT0gXCJtdWx0aWxpbmtcIiAmJiBub2RlLmxpbmt0eXBlID09PSBcInN0b3J5XCIgJiYgdHlwZW9mIG5vZGUuaWQgPT09IFwic3RyaW5nXCIgJiYgdGhpcy5saW5rc1tyZXNvbHZlSWRdW25vZGUuaWRdKSBub2RlLnN0b3J5ID0gdGhpcy5fY2xlYW5Db3B5KHRoaXMubGlua3NbcmVzb2x2ZUlkXVtub2RlLmlkXSk7XG5cdFx0ZWxzZSBpZiAobm9kZSAmJiBub2RlLmxpbmt0eXBlID09PSBcInN0b3J5XCIgJiYgdHlwZW9mIG5vZGUudXVpZCA9PT0gXCJzdHJpbmdcIiAmJiB0aGlzLmxpbmtzW3Jlc29sdmVJZF1bbm9kZS51dWlkXSkgbm9kZS5zdG9yeSA9IHRoaXMuX2NsZWFuQ29weSh0aGlzLmxpbmtzW3Jlc29sdmVJZF1bbm9kZS51dWlkXSk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAcGFyYW0gcmVzb2x2ZUlkIEEgY291bnRlciBudW1iZXIgYXMgYSBzdHJpbmdcblx0KiBAcGFyYW0gdXVpZCBUaGUgdXVpZCBvZiB0aGUgc3Rvcnlcblx0KiBAcmV0dXJucyBzdHJpbmcgfCBvYmplY3Rcblx0Ki9cblx0Z2V0U3RvcnlSZWZlcmVuY2UocmVzb2x2ZUlkLCB1dWlkKSB7XG5cdFx0Y29uc3QgcmVzdWx0ID0gdGhpcy5yZWxhdGlvbnNbcmVzb2x2ZUlkXVt1dWlkXSA/IEpTT04ucGFyc2UodGhpcy5zdHJpbmdpZmllZFN0b3JpZXNDYWNoZVt1dWlkXSB8fCBKU09OLnN0cmluZ2lmeSh0aGlzLnJlbGF0aW9uc1tyZXNvbHZlSWRdW3V1aWRdKSkgOiB1dWlkO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblx0LyoqXG5cdCogUmVzb2x2ZXMgYSBmaWVsZCdzIHZhbHVlIGJ5IHJlcGxhY2luZyBVVUlEcyB3aXRoIHRoZWlyIGNvcnJlc3BvbmRpbmcgc3RvcnkgcmVmZXJlbmNlc1xuXHQqIEBwYXJhbSBqdHJlZSAtIFRoZSBKU09OIHRyZWUgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZpZWxkIHRvIHJlc29sdmVcblx0KiBAcGFyYW0gdHJlZUl0ZW0gLSBUaGUga2V5IG9mIHRoZSBmaWVsZCB0byByZXNvbHZlXG5cdCogQHBhcmFtIHJlc29sdmVJZCAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGN1cnJlbnQgcmVzb2x1dGlvbiBjb250ZXh0XG5cdCpcblx0KiBUaGlzIG1ldGhvZCBoYW5kbGVzIGJvdGggc2luZ2xlIHN0cmluZyBVVUlEcyBhbmQgYXJyYXlzIG9mIFVVSURzOlxuXHQqIC0gRm9yIHNpbmdsZSBzdHJpbmdzOiBkaXJlY3RseSByZXBsYWNlcyB0aGUgVVVJRCB3aXRoIHRoZSBzdG9yeSByZWZlcmVuY2Vcblx0KiAtIEZvciBhcnJheXM6IG1hcHMgdGhyb3VnaCBlYWNoIFVVSUQgYW5kIHJlcGxhY2VzIHdpdGggY29ycmVzcG9uZGluZyBzdG9yeSByZWZlcmVuY2VzXG5cdCovXG5cdF9yZXNvbHZlRmllbGQoanRyZWUsIHRyZWVJdGVtLCByZXNvbHZlSWQpIHtcblx0XHRjb25zdCBpdGVtID0ganRyZWVbdHJlZUl0ZW1dO1xuXHRcdGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIikganRyZWVbdHJlZUl0ZW1dID0gdGhpcy5nZXRTdG9yeVJlZmVyZW5jZShyZXNvbHZlSWQsIGl0ZW0pO1xuXHRcdGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIGp0cmVlW3RyZWVJdGVtXSA9IGl0ZW0ubWFwKCh1dWlkKSA9PiB0aGlzLmdldFN0b3J5UmVmZXJlbmNlKHJlc29sdmVJZCwgdXVpZCkpLmZpbHRlcihCb29sZWFuKTtcblx0fVxuXHQvKipcblx0KiBJbnNlcnRzIHJlbGF0aW9ucyBpbnRvIHRoZSBKU09OIHRyZWUgYnkgcmVzb2x2aW5nIHJlZmVyZW5jZXNcblx0KiBAcGFyYW0ganRyZWUgLSBUaGUgSlNPTiB0cmVlIG9iamVjdCB0byBwcm9jZXNzXG5cdCogQHBhcmFtIHRyZWVJdGVtIC0gVGhlIGN1cnJlbnQgZmllbGQgYmVpbmcgcHJvY2Vzc2VkXG5cdCogQHBhcmFtIGZpZWxkcyAtIFRoZSByZWxhdGlvbiBwYXR0ZXJucyB0byByZXNvbHZlIChzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncylcblx0KiBAcGFyYW0gcmVzb2x2ZUlkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgY3VycmVudCByZXNvbHV0aW9uIGNvbnRleHRcblx0KlxuXHQqIFRoaXMgbWV0aG9kIGhhbmRsZXMgdHdvIHR5cGVzIG9mIHJlbGF0aW9uIHBhdHRlcm5zOlxuXHQqIDEuIE5lc3RlZCByZWxhdGlvbnM6IG1hdGNoZXMgZmllbGRzIHRoYXQgZW5kIHdpdGggdGhlIGN1cnJlbnQgZmllbGQgbmFtZVxuXHQqICAgIEV4YW1wbGU6IElmIHRyZWVJdGVtIGlzIFwiZXZlbnRfdHlwZVwiLCBpdCBtYXRjaGVzIHBhdHRlcm5zIGxpa2UgXCIqLmV2ZW50X3R5cGVcIlxuXHQqXG5cdCogMi4gRGlyZWN0IGNvbXBvbmVudCByZWxhdGlvbnM6IG1hdGNoZXMgZXhhY3QgY29tcG9uZW50LmZpZWxkIHBhdHRlcm5zXG5cdCogICAgRXhhbXBsZTogXCJldmVudC5ldmVudF90eXBlXCIgZm9yIGNvbXBvbmVudCBcImV2ZW50XCIgYW5kIGZpZWxkIFwiZXZlbnRfdHlwZVwiXG5cdCpcblx0KiBUaGUgbWV0aG9kIHN1cHBvcnRzIGJvdGggc3RyaW5nIGFuZCBhcnJheSBmb3JtYXRzIGZvciB0aGUgZmllbGRzIHBhcmFtZXRlcixcblx0KiBhbGxvd2luZyBmbGV4aWJsZSBzcGVjaWZpY2F0aW9uIG9mIHJlbGF0aW9uIHBhdHRlcm5zLlxuXHQqL1xuXHRfaW5zZXJ0UmVsYXRpb25zKGp0cmVlLCB0cmVlSXRlbSwgZmllbGRzLCByZXNvbHZlSWQpIHtcblx0XHRjb25zdCBmaWVsZFBhdHRlcm4gPSBBcnJheS5pc0FycmF5KGZpZWxkcykgPyBmaWVsZHMuZmluZCgoZikgPT4gZi5lbmRzV2l0aChgLiR7dHJlZUl0ZW19YCkpIDogZmllbGRzLmVuZHNXaXRoKGAuJHt0cmVlSXRlbX1gKTtcblx0XHRpZiAoZmllbGRQYXR0ZXJuKSB7XG5cdFx0XHR0aGlzLl9yZXNvbHZlRmllbGQoanRyZWUsIHRyZWVJdGVtLCByZXNvbHZlSWQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRjb25zdCBmaWVsZFBhdGggPSBqdHJlZS5jb21wb25lbnQgPyBgJHtqdHJlZS5jb21wb25lbnR9LiR7dHJlZUl0ZW19YCA6IHRyZWVJdGVtO1xuXHRcdGlmIChBcnJheS5pc0FycmF5KGZpZWxkcykgPyBmaWVsZHMuaW5jbHVkZXMoZmllbGRQYXRoKSA6IGZpZWxkcyA9PT0gZmllbGRQYXRoKSB0aGlzLl9yZXNvbHZlRmllbGQoanRyZWUsIHRyZWVJdGVtLCByZXNvbHZlSWQpO1xuXHR9XG5cdC8qKlxuXHQqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlcyBhbmQgcmVzb2x2ZXMgcmVsYXRpb25zIGluIHRoZSBzdG9yeSBjb250ZW50IHRyZWVcblx0KiBAcGFyYW0gc3RvcnkgLSBUaGUgc3Rvcnkgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNvbnRlbnQgdG8gcHJvY2Vzc1xuXHQqIEBwYXJhbSBmaWVsZHMgLSBUaGUgcmVsYXRpb24gcGF0dGVybnMgdG8gcmVzb2x2ZVxuXHQqIEBwYXJhbSByZXNvbHZlSWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBjdXJyZW50IHJlc29sdXRpb24gY29udGV4dFxuXHQqL1xuXHRpdGVyYXRlVHJlZShzdG9yeSwgZmllbGRzLCByZXNvbHZlSWQpIHtcblx0XHRjb25zdCBlbnJpY2ggPSAoanRyZWUsIHBhdGggPSBcIlwiKSA9PiB7XG5cdFx0XHRpZiAoIWp0cmVlIHx8IGp0cmVlLl9zdG9wUmVzb2x2aW5nKSByZXR1cm47XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShqdHJlZSkpIGp0cmVlLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiBlbnJpY2goaXRlbSwgYCR7cGF0aH1bJHtpbmRleH1dYCkpO1xuXHRcdFx0ZWxzZSBpZiAodHlwZW9mIGp0cmVlID09PSBcIm9iamVjdFwiKSBmb3IgKGNvbnN0IGtleSBpbiBqdHJlZSkge1xuXHRcdFx0XHRjb25zdCBuZXdQYXRoID0gcGF0aCA/IGAke3BhdGh9LiR7a2V5fWAgOiBrZXk7XG5cdFx0XHRcdGlmIChqdHJlZS5jb21wb25lbnQgJiYganRyZWUuX3VpZCB8fCBqdHJlZS50eXBlID09PSBcImxpbmtcIikge1xuXHRcdFx0XHRcdHRoaXMuX2luc2VydFJlbGF0aW9ucyhqdHJlZSwga2V5LCBmaWVsZHMsIHJlc29sdmVJZCk7XG5cdFx0XHRcdFx0dGhpcy5faW5zZXJ0TGlua3MoanRyZWUsIGtleSwgcmVzb2x2ZUlkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbnJpY2goanRyZWVba2V5XSwgbmV3UGF0aCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRlbnJpY2goc3RvcnkuY29udGVudCk7XG5cdH1cblx0YXN5bmMgcmVzb2x2ZUxpbmtzKHJlc3BvbnNlRGF0YSwgcGFyYW1zLCByZXNvbHZlSWQpIHtcblx0XHRsZXQgbGlua3MgPSBbXTtcblx0XHRpZiAocmVzcG9uc2VEYXRhLmxpbmtfdXVpZHMpIHtcblx0XHRcdGNvbnN0IHJlbFNpemUgPSByZXNwb25zZURhdGEubGlua191dWlkcy5sZW5ndGg7XG5cdFx0XHRjb25zdCBjaHVua3MgPSBbXTtcblx0XHRcdGNvbnN0IGNodW5rU2l6ZSA9IDUwO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByZWxTaXplOyBpICs9IGNodW5rU2l6ZSkge1xuXHRcdFx0XHRjb25zdCBlbmQgPSBNYXRoLm1pbihyZWxTaXplLCBpICsgY2h1bmtTaXplKTtcblx0XHRcdFx0Y2h1bmtzLnB1c2gocmVzcG9uc2VEYXRhLmxpbmtfdXVpZHMuc2xpY2UoaSwgZW5kKSk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKGxldCBjaHVua0luZGV4ID0gMDsgY2h1bmtJbmRleCA8IGNodW5rcy5sZW5ndGg7IGNodW5rSW5kZXgrKykge1xuXHRcdFx0XHRjb25zdCBsaW5rc1JlcyA9IGF3YWl0IHRoaXMuZ2V0U3Rvcmllcyh7XG5cdFx0XHRcdFx0cGVyX3BhZ2U6IGNodW5rU2l6ZSxcblx0XHRcdFx0XHRsYW5ndWFnZTogcGFyYW1zLmxhbmd1YWdlLFxuXHRcdFx0XHRcdHZlcnNpb246IHBhcmFtcy52ZXJzaW9uLFxuXHRcdFx0XHRcdHN0YXJ0c193aXRoOiBwYXJhbXMuc3RhcnRzX3dpdGgsXG5cdFx0XHRcdFx0YnlfdXVpZHM6IGNodW5rc1tjaHVua0luZGV4XS5qb2luKFwiLFwiKVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0bGlua3NSZXMuZGF0YS5zdG9yaWVzLmZvckVhY2goKHJlbCkgPT4ge1xuXHRcdFx0XHRcdGxpbmtzLnB1c2gocmVsKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGxpbmtzID0gcmVzcG9uc2VEYXRhLmxpbmtzO1xuXHRcdGxpbmtzLmZvckVhY2goKHN0b3J5KSA9PiB7XG5cdFx0XHR0aGlzLmxpbmtzW3Jlc29sdmVJZF1bc3RvcnkudXVpZF0gPSB7XG5cdFx0XHRcdC4uLnN0b3J5LFxuXHRcdFx0XHRfc3RvcFJlc29sdmluZzogdHJ1ZVxuXHRcdFx0fTtcblx0XHR9KTtcblx0fVxuXHRhc3luYyByZXNvbHZlUmVsYXRpb25zKHJlc3BvbnNlRGF0YSwgcGFyYW1zLCByZXNvbHZlSWQpIHtcblx0XHRsZXQgcmVsYXRpb25zID0gW107XG5cdFx0aWYgKHJlc3BvbnNlRGF0YS5yZWxfdXVpZHMpIHtcblx0XHRcdGNvbnN0IHJlbFNpemUgPSByZXNwb25zZURhdGEucmVsX3V1aWRzLmxlbmd0aDtcblx0XHRcdGNvbnN0IGNodW5rcyA9IFtdO1xuXHRcdFx0Y29uc3QgY2h1bmtTaXplID0gNTA7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHJlbFNpemU7IGkgKz0gY2h1bmtTaXplKSB7XG5cdFx0XHRcdGNvbnN0IGVuZCA9IE1hdGgubWluKHJlbFNpemUsIGkgKyBjaHVua1NpemUpO1xuXHRcdFx0XHRjaHVua3MucHVzaChyZXNwb25zZURhdGEucmVsX3V1aWRzLnNsaWNlKGksIGVuZCkpO1xuXHRcdFx0fVxuXHRcdFx0Zm9yIChsZXQgY2h1bmtJbmRleCA9IDA7IGNodW5rSW5kZXggPCBjaHVua3MubGVuZ3RoOyBjaHVua0luZGV4KyspIHtcblx0XHRcdFx0Y29uc3QgcmVsYXRpb25zUmVzID0gYXdhaXQgdGhpcy5nZXRTdG9yaWVzKHtcblx0XHRcdFx0XHRwZXJfcGFnZTogY2h1bmtTaXplLFxuXHRcdFx0XHRcdGxhbmd1YWdlOiBwYXJhbXMubGFuZ3VhZ2UsXG5cdFx0XHRcdFx0dmVyc2lvbjogcGFyYW1zLnZlcnNpb24sXG5cdFx0XHRcdFx0c3RhcnRzX3dpdGg6IHBhcmFtcy5zdGFydHNfd2l0aCxcblx0XHRcdFx0XHRieV91dWlkczogY2h1bmtzW2NodW5rSW5kZXhdLmpvaW4oXCIsXCIpLFxuXHRcdFx0XHRcdGV4Y2x1ZGluZ19maWVsZHM6IHBhcmFtcy5leGNsdWRpbmdfZmllbGRzXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZWxhdGlvbnNSZXMuZGF0YS5zdG9yaWVzLmZvckVhY2goKHJlbCkgPT4ge1xuXHRcdFx0XHRcdHJlbGF0aW9ucy5wdXNoKHJlbCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHJlbGF0aW9ucy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHJlc3BvbnNlRGF0YS5yZWxzID0gcmVsYXRpb25zO1xuXHRcdFx0XHRkZWxldGUgcmVzcG9uc2VEYXRhLnJlbF91dWlkcztcblx0XHRcdH1cblx0XHR9IGVsc2UgcmVsYXRpb25zID0gcmVzcG9uc2VEYXRhLnJlbHM7XG5cdFx0aWYgKHJlbGF0aW9ucyAmJiByZWxhdGlvbnMubGVuZ3RoID4gMCkgcmVsYXRpb25zLmZvckVhY2goKHN0b3J5KSA9PiB7XG5cdFx0XHR0aGlzLnJlbGF0aW9uc1tyZXNvbHZlSWRdW3N0b3J5LnV1aWRdID0ge1xuXHRcdFx0XHQuLi5zdG9yeSxcblx0XHRcdFx0X3N0b3BSZXNvbHZpbmc6IHRydWVcblx0XHRcdH07XG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAcGFyYW0gcmVzcG9uc2VEYXRhXG5cdCogQHBhcmFtIHBhcmFtc1xuXHQqIEBwYXJhbSByZXNvbHZlSWRcblx0KiBAZGVzY3JpcHRpb24gUmVzb2x2ZXMgdGhlIHJlbGF0aW9ucyBhbmQgbGlua3Mgb2YgdGhlIHN0b3JpZXNcblx0KiBAcmV0dXJucyBQcm9taXNlPHZvaWQ+XG5cdCpcblx0Ki9cblx0YXN5bmMgcmVzb2x2ZVN0b3JpZXMocmVzcG9uc2VEYXRhLCBwYXJhbXMsIHJlc29sdmVJZCkge1xuXHRcdGxldCByZWxhdGlvblBhcmFtcyA9IFtdO1xuXHRcdHRoaXMubGlua3NbcmVzb2x2ZUlkXSA9IHt9O1xuXHRcdHRoaXMucmVsYXRpb25zW3Jlc29sdmVJZF0gPSB7fTtcblx0XHRpZiAodHlwZW9mIHBhcmFtcy5yZXNvbHZlX3JlbGF0aW9ucyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwYXJhbXMucmVzb2x2ZV9yZWxhdGlvbnMubGVuZ3RoID4gMCkge1xuXHRcdFx0aWYgKHR5cGVvZiBwYXJhbXMucmVzb2x2ZV9yZWxhdGlvbnMgPT09IFwic3RyaW5nXCIpIHJlbGF0aW9uUGFyYW1zID0gcGFyYW1zLnJlc29sdmVfcmVsYXRpb25zLnNwbGl0KFwiLFwiKTtcblx0XHRcdGF3YWl0IHRoaXMucmVzb2x2ZVJlbGF0aW9ucyhyZXNwb25zZURhdGEsIHBhcmFtcywgcmVzb2x2ZUlkKTtcblx0XHR9XG5cdFx0aWYgKHBhcmFtcy5yZXNvbHZlX2xpbmtzICYmIFtcblx0XHRcdFwiMVwiLFxuXHRcdFx0XCJzdG9yeVwiLFxuXHRcdFx0XCJ1cmxcIixcblx0XHRcdFwibGlua1wiXG5cdFx0XS5pbmNsdWRlcyhwYXJhbXMucmVzb2x2ZV9saW5rcykgJiYgKHJlc3BvbnNlRGF0YS5saW5rcz8ubGVuZ3RoIHx8IHJlc3BvbnNlRGF0YS5saW5rX3V1aWRzPy5sZW5ndGgpKSBhd2FpdCB0aGlzLnJlc29sdmVMaW5rcyhyZXNwb25zZURhdGEsIHBhcmFtcywgcmVzb2x2ZUlkKTtcblx0XHRpZiAodGhpcy5yZXNvbHZlTmVzdGVkUmVsYXRpb25zKSBmb3IgKGNvbnN0IHJlbFV1aWQgaW4gdGhpcy5yZWxhdGlvbnNbcmVzb2x2ZUlkXSkgdGhpcy5pdGVyYXRlVHJlZSh0aGlzLnJlbGF0aW9uc1tyZXNvbHZlSWRdW3JlbFV1aWRdLCByZWxhdGlvblBhcmFtcywgcmVzb2x2ZUlkKTtcblx0XHRpZiAocmVzcG9uc2VEYXRhLnN0b3J5KSB0aGlzLml0ZXJhdGVUcmVlKHJlc3BvbnNlRGF0YS5zdG9yeSwgcmVsYXRpb25QYXJhbXMsIHJlc29sdmVJZCk7XG5cdFx0ZWxzZSByZXNwb25zZURhdGEuc3Rvcmllcy5mb3JFYWNoKChzdG9yeSkgPT4ge1xuXHRcdFx0dGhpcy5pdGVyYXRlVHJlZShzdG9yeSwgcmVsYXRpb25QYXJhbXMsIHJlc29sdmVJZCk7XG5cdFx0fSk7XG5cdFx0dGhpcy5zdHJpbmdpZmllZFN0b3JpZXNDYWNoZSA9IHt9O1xuXHRcdGRlbGV0ZSB0aGlzLmxpbmtzW3Jlc29sdmVJZF07XG5cdFx0ZGVsZXRlIHRoaXMucmVsYXRpb25zW3Jlc29sdmVJZF07XG5cdH1cblx0YXN5bmMgY2FjaGVSZXNwb25zZSh1cmwsIHBhcmFtcywgcmV0cmllcywgZmV0Y2hPcHRpb25zKSB7XG5cdFx0Y29uc3QgY2FjaGVLZXkgPSBzdHJpbmdpZnkoe1xuXHRcdFx0dXJsLFxuXHRcdFx0cGFyYW1zXG5cdFx0fSk7XG5cdFx0Y29uc3QgcHJvdmlkZXIgPSB0aGlzLmNhY2hlUHJvdmlkZXIoKTtcblx0XHRpZiAocGFyYW1zLnZlcnNpb24gPT09IFwicHVibGlzaGVkXCIgJiYgdXJsICE9PSBcIi9jZG4vc3BhY2VzL21lXCIpIHtcblx0XHRcdGNvbnN0IGNhY2hlID0gYXdhaXQgcHJvdmlkZXIuZ2V0KGNhY2hlS2V5KTtcblx0XHRcdGlmIChjYWNoZSkgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjYWNoZSk7XG5cdFx0fVxuXHRcdHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb25zdCByZXMgPSBhd2FpdCB0aGlzLnRocm90dGxlKFwiZ2V0XCIsIHVybCwgcGFyYW1zLCBmZXRjaE9wdGlvbnMpO1xuXHRcdFx0XHRpZiAocmVzLnN0YXR1cyAhPT0gMjAwKSByZXR1cm4gcmVqZWN0KHJlcyk7XG5cdFx0XHRcdGxldCByZXNwb25zZSA9IHtcblx0XHRcdFx0XHRkYXRhOiByZXMuZGF0YSxcblx0XHRcdFx0XHRoZWFkZXJzOiByZXMuaGVhZGVyc1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAocmVzLmhlYWRlcnM/LltcInBlci1wYWdlXCJdKSByZXNwb25zZSA9IE9iamVjdC5hc3NpZ24oe30sIHJlc3BvbnNlLCB7XG5cdFx0XHRcdFx0cGVyUGFnZTogcmVzLmhlYWRlcnNbXCJwZXItcGFnZVwiXSA/IE51bWJlci5wYXJzZUludChyZXMuaGVhZGVyc1tcInBlci1wYWdlXCJdKSA6IDAsXG5cdFx0XHRcdFx0dG90YWw6IHJlcy5oZWFkZXJzW1wicGVyLXBhZ2VcIl0gPyBOdW1iZXIucGFyc2VJbnQocmVzLmhlYWRlcnMudG90YWwpIDogMFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0aWYgKHJlc3BvbnNlLmRhdGEuc3RvcnkgfHwgcmVzcG9uc2UuZGF0YS5zdG9yaWVzKSB7XG5cdFx0XHRcdFx0Y29uc3QgcmVzb2x2ZUlkID0gdGhpcy5yZXNvbHZlQ291bnRlciA9ICsrdGhpcy5yZXNvbHZlQ291bnRlciAlIDFlMztcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnJlc29sdmVTdG9yaWVzKHJlc3BvbnNlLmRhdGEsIHBhcmFtcywgYCR7cmVzb2x2ZUlkfWApO1xuXHRcdFx0XHRcdHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcm9jZXNzSW5saW5lQXNzZXRzKHJlc3BvbnNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocGFyYW1zLnZlcnNpb24gPT09IFwicHVibGlzaGVkXCIgJiYgdXJsICE9PSBcIi9jZG4vc3BhY2VzL21lXCIpIGF3YWl0IHByb3ZpZGVyLnNldChjYWNoZUtleSwgcmVzcG9uc2UpO1xuXHRcdFx0XHRjb25zdCBpc0NhY2hlQ2xlYXJhYmxlID0gdGhpcy5jYWNoZS5jbGVhciA9PT0gXCJvbnByZXZpZXdcIiAmJiBwYXJhbXMudmVyc2lvbiA9PT0gXCJkcmFmdFwiIHx8IHRoaXMuY2FjaGUuY2xlYXIgPT09IFwiYXV0b1wiO1xuXHRcdFx0XHRpZiAocGFyYW1zLnRva2VuICYmIHJlc3BvbnNlLmRhdGEuY3YpIHtcblx0XHRcdFx0XHRpZiAoaXNDYWNoZUNsZWFyYWJsZSAmJiBjYWNoZVZlcnNpb25zW3BhcmFtcy50b2tlbl0gJiYgY2FjaGVWZXJzaW9uc1twYXJhbXMudG9rZW5dICE9PSByZXNwb25zZS5kYXRhLmN2KSBhd2FpdCB0aGlzLmZsdXNoQ2FjaGUoKTtcblx0XHRcdFx0XHRjYWNoZVZlcnNpb25zW3BhcmFtcy50b2tlbl0gPSByZXNwb25zZS5kYXRhLmN2O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZXNvbHZlKHJlc3BvbnNlKTtcblx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdGlmIChlcnJvci5yZXNwb25zZSAmJiBlcnJvci5zdGF0dXMgPT09IDQyOSkge1xuXHRcdFx0XHRcdHJldHJpZXMgPSB0eXBlb2YgcmV0cmllcyA9PT0gXCJ1bmRlZmluZWRcIiA/IDAgOiByZXRyaWVzICsgMTtcblx0XHRcdFx0XHRpZiAocmV0cmllcyA8IHRoaXMubWF4UmV0cmllcykge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coYEhpdCByYXRlIGxpbWl0LiBSZXRyeWluZyBpbiAke3RoaXMucmV0cmllc0RlbGF5IC8gMWUzfSBzZWNvbmRzLmApO1xuXHRcdFx0XHRcdFx0YXdhaXQgZGVsYXkodGhpcy5yZXRyaWVzRGVsYXkpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuY2FjaGVSZXNwb25zZSh1cmwsIHBhcmFtcywgcmV0cmllcykudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cdHRocm90dGxlZFJlcXVlc3QodHlwZSwgdXJsLCBwYXJhbXMsIGZldGNoT3B0aW9ucykge1xuXHRcdHRoaXMuY2xpZW50LnNldEZldGNoT3B0aW9ucyhmZXRjaE9wdGlvbnMpO1xuXHRcdHJldHVybiB0aGlzLmNsaWVudFt0eXBlXSh1cmwsIHBhcmFtcyk7XG5cdH1cblx0Y2FjaGVWZXJzaW9ucygpIHtcblx0XHRyZXR1cm4gY2FjaGVWZXJzaW9ucztcblx0fVxuXHRjYWNoZVZlcnNpb24oKSB7XG5cdFx0cmV0dXJuIGNhY2hlVmVyc2lvbnNbdGhpcy5hY2Nlc3NUb2tlbl07XG5cdH1cblx0c2V0Q2FjaGVWZXJzaW9uKGN2KSB7XG5cdFx0aWYgKHRoaXMuYWNjZXNzVG9rZW4pIGNhY2hlVmVyc2lvbnNbdGhpcy5hY2Nlc3NUb2tlbl0gPSBjdjtcblx0fVxuXHRjbGVhckNhY2hlVmVyc2lvbigpIHtcblx0XHRpZiAodGhpcy5hY2Nlc3NUb2tlbikgY2FjaGVWZXJzaW9uc1t0aGlzLmFjY2Vzc1Rva2VuXSA9IDA7XG5cdH1cblx0Y2FjaGVQcm92aWRlcigpIHtcblx0XHRzd2l0Y2ggKHRoaXMuY2FjaGUudHlwZSkge1xuXHRcdFx0Y2FzZSBcIm1lbW9yeVwiOiByZXR1cm4ge1xuXHRcdFx0XHRnZXQoa2V5KSB7XG5cdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShtZW1vcnlba2V5XSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGdldEFsbCgpIHtcblx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1lbW9yeSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNldChrZXksIGNvbnRlbnQpIHtcblx0XHRcdFx0XHRtZW1vcnlba2V5XSA9IGNvbnRlbnQ7XG5cdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSh2b2lkIDApO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRmbHVzaCgpIHtcblx0XHRcdFx0XHRtZW1vcnkgPSB7fTtcblx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZvaWQgMCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRjYXNlIFwiY3VzdG9tXCI6IGlmICh0aGlzLmNhY2hlLmN1c3RvbSkgcmV0dXJuIHRoaXMuY2FjaGUuY3VzdG9tO1xuXHRcdFx0ZGVmYXVsdDogcmV0dXJuIHtcblx0XHRcdFx0Z2V0KCkge1xuXHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0Z2V0QWxsKCkge1xuXHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUodm9pZCAwKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0c2V0KCkge1xuXHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUodm9pZCAwKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0Zmx1c2goKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSh2b2lkIDApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXHRhc3luYyBmbHVzaENhY2hlKCkge1xuXHRcdGF3YWl0IHRoaXMuY2FjaGVQcm92aWRlcigpLmZsdXNoKCk7XG5cdFx0dGhpcy5jbGVhckNhY2hlVmVyc2lvbigpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGFzeW5jIHByb2Nlc3NJbmxpbmVBc3NldHMocmVzcG9uc2UpIHtcblx0XHRpZiAoIXRoaXMuaW5saW5lQXNzZXRzKSByZXR1cm4gcmVzcG9uc2U7XG5cdFx0Y29uc3QgcHJvY2Vzc05vZGUgPSAobm9kZSkgPT4ge1xuXHRcdFx0aWYgKCFub2RlIHx8IHR5cGVvZiBub2RlICE9PSBcIm9iamVjdFwiKSByZXR1cm4gbm9kZTtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSByZXR1cm4gbm9kZS5tYXAoKGl0ZW0pID0+IHByb2Nlc3NOb2RlKGl0ZW0pKTtcblx0XHRcdGxldCBwcm9jZXNzZWROb2RlID0geyAuLi5ub2RlIH07XG5cdFx0XHRpZiAocHJvY2Vzc2VkTm9kZS5maWVsZHR5cGUgPT09IFwiYXNzZXRcIiAmJiBBcnJheS5pc0FycmF5KHJlc3BvbnNlLmRhdGEuYXNzZXRzKSkgcHJvY2Vzc2VkTm9kZSA9IHtcblx0XHRcdFx0Li4ucHJvY2Vzc2VkTm9kZSxcblx0XHRcdFx0Li4ucmVzcG9uc2UuZGF0YS5hc3NldHMuZmluZCgoYXNzZXQpID0+IGFzc2V0LmlkID09PSBwcm9jZXNzZWROb2RlLmlkKVxuXHRcdFx0fTtcblx0XHRcdGZvciAoY29uc3Qga2V5IGluIHByb2Nlc3NlZE5vZGUpIGlmICh0eXBlb2YgcHJvY2Vzc2VkTm9kZVtrZXldID09PSBcIm9iamVjdFwiKSBwcm9jZXNzZWROb2RlW2tleV0gPSBwcm9jZXNzTm9kZShwcm9jZXNzZWROb2RlW2tleV0pO1xuXHRcdFx0cmV0dXJuIHByb2Nlc3NlZE5vZGU7XG5cdFx0fTtcblx0XHRpZiAocmVzcG9uc2UuZGF0YS5zdG9yeSkgcmVzcG9uc2UuZGF0YS5zdG9yeS5jb250ZW50ID0gcHJvY2Vzc05vZGUocmVzcG9uc2UuZGF0YS5zdG9yeS5jb250ZW50KTtcblx0XHRpZiAocmVzcG9uc2UuZGF0YS5zdG9yaWVzKSByZXNwb25zZS5kYXRhLnN0b3JpZXMgPSByZXNwb25zZS5kYXRhLnN0b3JpZXMubWFwKChzdG9yeSkgPT4ge1xuXHRcdFx0c3RvcnkuY29udGVudCA9IHByb2Nlc3NOb2RlKHN0b3J5LmNvbnRlbnQpO1xuXHRcdFx0cmV0dXJuIHN0b3J5O1xuXHRcdH0pO1xuXHRcdHJldHVybiByZXNwb25zZTtcblx0fVxufTtcbnZhciBzcmNfZGVmYXVsdCA9IFN0b3J5YmxvaztcblxuLy8jZW5kcmVnaW9uXG5leHBvcnQgeyBTdG9yeWJsb2ssIHNyY19kZWZhdWx0IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/storyblok-js-client/dist/index.js\n");

/***/ })

};
;